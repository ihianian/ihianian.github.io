<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JUC并发编程与源码分析_01_概述, ihianian">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JUC并发编程与源码分析_01_概述 | ihianian</title>
    <link rel="icon" type="image/png" href="/header.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/header.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ihianian</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/404" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/404" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/header.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ihianian</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/404" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/404" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JUC并发编程与源码分析_01_概述</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JUC/">
                                <span class="chip bg-color">JUC</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-08-10
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-09-02
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    21.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    81 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>本文介绍JUC并发编程以及源码分析。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>JUC是<code>java.util.concurrent</code>的缩写，主要涉及到以下三个包：</p>
<ol>
<li>java.util.concurrent：并发编程的基础包</li>
<li>java.util.concurrent.atomic：并发编程的原子包</li>
<li>java.util.concurrent.locks：并发编程的锁包</li>
</ol>
<p>那么为什么会出现并发编程呢？</p>
<blockquote>
<p>摩尔定律失效，CPU的主频已经到了极限，不再翻倍。而是在核数上做文章，即多核。</p>
<p>在主频不再提高且核数在不断增加的情况下，要想让程序更快就要用到并行或并发编程。</p>
</blockquote>
<p>利用并发编程，可以充分利用多核处理器，提高程序性能，形成高并发系统。并且可以提高程序吞吐量， 处理异步+回调等生产请求。</p>
<p>演变：单机单线程——&gt;单机多线程——&gt;多机多线程。</p>
<p>但是除了上面的优点，其实也有一定的弊端和问题，如：</p>
<ol>
<li>线程安全问题：比如i++这种非原子操作、集合类等数据结构是否安全等等（比如StringBuffer、Vector、HashTable等都是线程安全的）。</li>
<li>线程锁问题：Synchronized重量级锁</li>
<li>线程性能问题：线程并发处理不当，导致性能下降，死锁等等。</li>
</ol>
<p><strong>因此，在引入并发之后，还需要处理随之而来的一系列问题。</strong></p>
<h2 id="2-进程-线程回顾"><a href="#2-进程-线程回顾" class="headerlink" title="2. 进程/线程回顾"></a>2. 进程/线程回顾</h2><h3 id="2-1-进程-线程是什么"><a href="#2-1-进程-线程是什么" class="headerlink" title="2.1 进程/线程是什么"></a>2.1 进程/线程是什么</h3><p>简单地说，进程就是后台的一个运行程序，是操作系统层面的，进程是分配资源的基本单位。线程则是进程中的一部分，负责处理某个请求，是调度的基本单位，共享某个进程中的资源。比如Java程序运行，这就是启动了一个进程，其中有垃圾回收线程，main线程等等。又或者word中，会有备份容灾线程（突然断电，或者突然关闭，自动备份一份），拼写单词检查线程（自动红色波浪线）等等。</p>
<h3 id="2-2-线程的状态"><a href="#2-2-线程的状态" class="headerlink" title="2.2 线程的状态"></a>2.2 线程的状态</h3><p>创建、就绪、运行、阻塞、消亡。</p>
<h3 id="2-3-wait-sleep的区别？"><a href="#2-3-wait-sleep的区别？" class="headerlink" title="2.3 wait/sleep的区别？"></a>2.3 wait/sleep的区别？</h3><blockquote>
<p>sleep是放弃时间片进入阻塞状态，sleep时间过后，自动进入就绪状态。而wait则是主动释放掉资源，进入无限期等待状态，必须唤醒notify()才会重新进入就绪状态。</p>
</blockquote>
<ol>
<li>wait是Object类中的方法，而sleep是Thread中的静态方法。</li>
<li>如果wait没有设置时间，则会进入无限期等待状态【阻塞】，必须通过notify()方法来主动唤醒，之后进入就绪状态；而sleep则必须设置时间【阻塞】，时间过后，则会进入就绪状态。【都是释放出CPU时间片】。sleep可以通过interupt()来提前终止sleep。</li>
<li>sleep不会释放资源锁，而wait会释放。</li>
<li>sleep属于线程级别，可以在任何地方使用。而wait只能在synchronized语句块中使用【即必须占有资源所之后，才会wait释放】</li>
</ol>
<h3 id="2-4-并发-并行是什么？"><a href="#2-4-并发-并行是什么？" class="headerlink" title="2.4 并发/并行是什么？"></a>2.4 并发/并行是什么？</h3><p>并行，无论宏观还是围观上，都是一起执行。并发，宏观上是一起执行，但是微观上，则是断断续续地交替串行执行的。</p>
<h3 id="2-5-补充"><a href="#2-5-补充" class="headerlink" title="2.5 补充"></a>2.5 补充</h3><p>在集合中，ArrayList是线程不安全的，多线程并发修改和读取，在高并发情况下，会出现java.util.ConcurrentModificationException异常。而Vector则是线程安全的。</p>
<p>因此，如果使用ArrayList出现了线程不安全：</p>
<ol>
<li><p>可以使用Vector替代，</p>
</li>
<li><p>可以使用Collections工具类中的一些方法，如<code>Collections.synchronizedList(new ArrayList())</code>，即将不安全的数据结构转换为线程安全的结构。</p>
</li>
<li><p>也可使用JUC下的java.util.concurrent.CopyOnWriteArrayList类</p>
<p>该类就是写时复制、读写分离的变种，类似MVCC。即读的时候，允许并发读；而写的时候，只能加锁。<strong>写的时候，复制一版，一版供读，另一版供写。</strong>add源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        es[len] = e;</span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即，在写操作的时候，复制一版，然后并将写后的数组重新复制给原始数组。</p>
</li>
</ol>
<p>同理，HashSet也是线程不安全的，同样，JUC也提供了<code>java.util.concurrent.CopyOnWriteArraySet</code>类。HashMap也是线程不安全的，JUC提供了<code>java.util.concurrent.ConcurrentHashMap</code>类。</p>
<h2 id="3-java-util-concurrent-locks"><a href="#3-java-util-concurrent-locks" class="headerlink" title="3. java.util.concurrent.locks"></a>3. java.util.concurrent.locks</h2><p>locks包里面有三个接口：</p>
<ol>
<li>Lock：排他锁</li>
<li>Condition：与Lock匹配的钥匙</li>
<li>ReadWriteLock：读写分离锁</li>
</ol>
<h3 id="3-1-Lock"><a href="#3-1-Lock" class="headerlink" title="3.1 Lock"></a>3.1 Lock</h3><p>在前面进线程中提到过，解决并发安全问题，除了synchronized之外，还有Lock锁。<code>java.util.concurrent.locks.Lock</code>是一个接口，其主要的实现类有:</p>
<ul>
<li>java.util.concurrent.locks.ReentrantLock：可重入锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Condition"><a href="#3-2-Condition" class="headerlink" title="3.2 Condition"></a>3.2 Condition</h3><p>而与Lock锁匹配的“钥匙”，则是<code>java.util.concurrent.locks.Condition</code>接口，可由<code>lock.newCondition()</code>方法获得实现类对象。</p>
<h3 id="3-3-ReadWriteLock"><a href="#3-3-ReadWriteLock" class="headerlink" title="3.3 ReadWriteLock"></a>3.3 ReadWriteLock</h3><p>该接口就是读写锁。实现类是：</p>
<ul>
<li>java.util.concurrent.locks.ReentrantReadWriteLock</li>
</ul>
<p>该类里面有两个内部类（ReadLock、WriteLock），并且通过方法，创建了实例，返回这两个对象。</p>
<h2 id="4-JUC辅助类"><a href="#4-JUC辅助类" class="headerlink" title="4. JUC辅助类"></a>4. JUC辅助类</h2><h3 id="4-1-CountDownLatch"><a href="#4-1-CountDownLatch" class="headerlink" title="4.1 CountDownLatch"></a>4.1 CountDownLatch</h3><p>这个工具类可以限制某个线程，<strong>等待多少个线程结束之后才执行</strong>。即阻塞某线程，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest24</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">// 计数</span></span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待计数结束，即为0时，才会继续执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;最后关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-CyclicBarrier"><a href="#4-2-CyclicBarrier" class="headerlink" title="4.2 CyclicBarrier"></a>4.2 CyclicBarrier</h3><p>这个类，是等待几个线程都开始运行了，才开始运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待收集完成之后，执行里面的Runnable实现类线程。</span></span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, ()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span>  <span class="keyword">int</span> tempInt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收集到第：&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();  <span class="comment">// 收集龙珠，等待其他几个线程。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Semaphore"><a href="#4-3-Semaphore" class="headerlink" title="4.3 Semaphore"></a>4.3 Semaphore</h3><p>信号量就是一种资源，线程抢不到会一直等待。如果信号量的数量为1，那么就等同于锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>); <span class="comment">// 设置信号量为3，即资源数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取信号量，资源自动减一</span></span><br><span class="line">            <span class="comment">// 抢不到会一直等下去，，直到有线程释放信号量，或超时。</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t抢到了车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停一会线程</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t离开了线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放资源，资源自动加一</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-java-util-concurrent"><a href="#5-java-util-concurrent" class="headerlink" title="5. java.util.concurrent"></a>5. java.util.concurrent</h2><p>这个包里面的接口有很多个，常用的有：</p>
<ol>
<li>BlockingQueue</li>
<li>Callable</li>
<li>Executor</li>
<li>Future</li>
</ol>
<h3 id="5-1-BlockingQueue阻塞队列"><a href="#5-1-BlockingQueue阻塞队列" class="headerlink" title="5.1 BlockingQueue阻塞队列"></a>5.1 BlockingQueue阻塞队列</h3><p>信号量只是一个标志，并不是程序真正处理的数据，但是获取不到信号量就会一直阻塞下去。而阻塞队列也类似，获取不到队列中的数据也会一直阻塞下去；但是阻塞队列存储的数据就是程序真正处理的数据。</p>
<p>除了BlockingQueue，还有BlockingDeque双向队列。这两个都是接口，实现类有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue（只存储一个元素）等。</p>
<p>队列和list类似，一样有add、offer等方法，只不过有的方法会产生阻塞，有的则不会。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_001.png"></p>
<h2 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6. 线程池"></a>6. 线程池</h2><p>在进程/线程的时候，提到过线程池，无需我们手动创建线程启动线程。线程池在创建的时候，可以指定创建几个线程。然后我们只需要将任务创建好，将其放到线程池中即可。线程池会自动分配线程取执行这个任务。</p>
<p><strong>线程池一方面直接一次性创建多个线程，直接使用。另一方面，线程执行完任务之后，不会销毁，继续保留，等待复用线程。</strong></p>
<p>线程池的优势：</p>
<blockquote>
<p>线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务。如果任务数量超过了最大线程数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：线程复用；控制最大并发数；管理线程。</p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统西园，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
</blockquote>
<p>线程池主要涉及到的接口和类有：</p>
<ol>
<li><code>java.util.concurrent.Executor</code>接口，</li>
<li><code>java.util.concurrent.ExecutorService</code>接口【主要用这个接口】</li>
<li><code>java.util.concurrent.ThreadPoolExecutor</code>【实现类】</li>
<li><code>java.util.concurrent.Executors</code>工具类。</li>
</ol>
<p>线程池有5个线程，依次有10个任务交给线程池工作。简单案例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest25</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line"></span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t办理任务&quot;</span> + temp);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_002.png" alt="image-20220817144059421"></p>
<h3 id="6-1-ThreadPoolExecutor"><a href="#6-1-ThreadPoolExecutor" class="headerlink" title="6.1 ThreadPoolExecutor"></a>6.1 ThreadPoolExecutor</h3><p>线程池最重要的类就是java.util.concurrent.ThreadPoolExecutor，这个类是线程池类。虽然通过工具类可创建各种线程池，但本质上都是通过传入不同的参数，创建线程池对象。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Executors.newCachedThreadPool()</td>
<td>创建一个可根据需要创建新线程的线程池。可扩容</td>
</tr>
<tr>
<td>Executors.newFixedThreadPool(n)</td>
<td>创建一个可重用固定线程数的线程池。</td>
</tr>
<tr>
<td>Executors.newSingleThreadExecutor()</td>
<td>创建一个只有一个线程的线程池。</td>
</tr>
<tr>
<td>Executors.newScheduledThreadPool(n)</td>
<td>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</td>
</tr>
</tbody></table>
<p><strong>本质上还是构造方法</strong>，ThreadPoolExecutor的构造方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心有七个参数，六个属性。</p>
<ol>
<li><p>corePoolSize</p>
<p>线程池中的<strong>常驻核心线程数</strong>（常驻指的就是值班的人）</p>
</li>
<li><p>maximumPoolSize</p>
<p><strong>线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</strong>。（类似，银行的窗口数，有时候不一定窗口都开，即非核心线程，但是最多只能开窗口数。）</p>
</li>
<li><p>keepAliveTime</p>
<p><strong>多余的空闲线程的存活时间</strong>，当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁，直到只剩下corePoolSize个线程为止。</p>
</li>
<li><p>unit</p>
<p>keepAliveTime的单位</p>
</li>
<li><p>workQueue</p>
<p>任务队列，被提交但尚未被执行的任务。就是阻塞队列，任务太多，线程处理不过来，就存放到阻塞队列中。（类似银行中的候客区）</p>
</li>
<li><p>threadFactory</p>
<p>表示生成线程池中工作线程的<strong>线程工厂，用于创建线程</strong>，<strong>一般默认的即可</strong>。</p>
</li>
<li><p>handler</p>
<p>拒绝策略，表示当任务队列满了，并且工作线程大于整个线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的Runnable的策略。（保持默认即可）</p>
</li>
</ol>
<h3 id="6-2-线程池工作原理"><a href="#6-2-线程池工作原理" class="headerlink" title="6.2 线程池工作原理"></a>6.2 线程池工作原理</h3><blockquote>
<p>其实线程池完全可以类比银行办理业务，肯定需要窗口（并行最大容量），但是一般情况下，客流量没那么大，所以窗口只开少数几个（核心线程）。如果任务量大，显然需要存放任务，即候客区（阻塞队列）。在客流量大的情况下，候客区必定会存放满；此时只能开放剩余窗口。但是客流量不一定时刻都大，那么什么时候关闭多余的几个窗口呢？空闲窗口的空闲时间达到一定时间，就会关闭（即存活时间）。另外，开放窗口也是需要有人来开放的，即线程工厂，负责创建线程。最后，如果客流量太多了，候客区满了之后，开放全部窗口仍然无法处理客流量，此时只能拒绝进入，即拒绝策略。</p>
</blockquote>
<p>核心线程 -&gt;  阻塞队列 -&gt; 扩容直至最大线程数量，最终拒绝策略。扩容线程需要线程工厂，非核心线程在空闲之后，经过存活时间就会消亡。</p>
<h3 id="6-3-参数设置"><a href="#6-3-参数设置" class="headerlink" title="6.3 参数设置"></a>6.3 参数设置</h3><p>上面的三个线程池：单一的，固定数量的，可扩容的，哪个用的多？<strong>一个都不用，工作中使用自定义的</strong>。因为：</p>
<ol>
<li>FixedThreadPool和SingleThreadPool，允许的请求队列长度为Integer.MAX_VALUE，即阻塞队列很长，这就会导致堆积大量的请求，从而导致OOM。</li>
<li>CachedThreadPool和ScheduledThreadPool，允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</li>
</ol>
<p>CPU密集型：CPU核数+1就是最大线程数。</p>
<p>IO密集型：CPU核数*2就是最大线程数。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yudianxiaoxiao/article/details/115134748">CPU 密集型 和 IO密集型 的区别，如何确定线程池大小？_醋酸菌HaC的博客-CSDN博客_cpu密集型和io密集型区别</a></p>
<h3 id="6-4-四大拒绝策略"><a href="#6-4-四大拒绝策略" class="headerlink" title="6.4 四大拒绝策略"></a>6.4 四大拒绝策略</h3><ol>
<li>AboryPolicy(默认)：直接抛出RejectedExecutionException异常，阻止系统正常运行</li>
<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。<strong>即回退到调用者，让调用者执行这个任务。</strong></li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中，尝试再次提交当前任务。</li>
<li>DiscardPloicy：该策略默默丢弃无法处理的任务，不予处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</li>
</ol>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest25</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        try&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                final int temp = i;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                threadPool.execute(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(Thread.currentThread().getName() + &quot;\t办理任务&quot; + temp);</span></span><br><span class="line"><span class="comment">//                &#125;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125; catch(Exception e)&#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//            threadPool.shutdown();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line"><span class="comment">//                new ThreadPoolExecutor.AbortPolicy()  // 终止策略</span></span><br><span class="line"><span class="comment">//                new ThreadPoolExecutor.CallerRunsPolicy()   // 调用者运行策略</span></span><br><span class="line"><span class="comment">//                new ThreadPoolExecutor.DiscardPolicy()   // 抛弃策略</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()   <span class="comment">// 抛弃策略(阻塞队列中最老的)</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line"></span><br><span class="line">                executorService.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t办理任务&quot;</span> + temp);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-JMM"><a href="#7-JMM" class="headerlink" title="7. JMM"></a>7. JMM</h2><p>JMM是Java Memory Model的简称，即Java内存模型。</p>
<h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p>首先回顾操作系统的知识，我们知道，数据存储在硬盘中，然后加载到内存中。之后CPU中就直接读取内存中的数据，放到寄存器进行操作数据。内存的出现就是为了缓解硬盘的缺陷【IO速度慢】，而缓存的出现则是为了进一步优化内存【内存的速度比不过CPU的计算速度】。<strong>换句话说，CPU的计算速度远高于硬盘的读写速度，因此，出现了内存，而内存的速度虽然比硬盘高了不少，但是仍然低于CPU的计算速度，此时就出现了缓存。本质上说，就是为了降低CPU的空闲时间。使得其等待时间较短，即计算出结果就立马写入成功，直接进行下一次计算，无需等待写入IO。</strong></p>
<p>查看计算机的CPU缓存，可任务管理器-&gt;性能-&gt;点击CPU就会出现。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_003.png"></p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_004.png" alt="image-20220818101114145"></p>
<p>但是我们知道，Java的一个特性就是跨平台，显然一个程序在不同的平台下运行的状态应该是一样的。<strong>注意，这的状态指的不仅仅是运行结果，而且还有运行时间、内存访问等等。</strong>此时就需要考虑底层硬件的差异。但是有的系统有一级缓存，有的是二级缓存等等。这时候应该怎么办呢？如何屏蔽掉不同操作系统不同硬件的缓存之间的差异呢？</p>
<blockquote>
<p>Java是通过JVM来屏蔽操作系统的差异的，因此JVM规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异。以实现Java程序在各种平台下都能达到一致的内存访问效果。</p>
</blockquote>
<h3 id="7-2-JMM"><a href="#7-2-JMM" class="headerlink" title="7.2 JMM"></a>7.2 JMM</h3><p>JMM本身是一种抽象的概念，并不是真实存在的实体，它仅仅描述的是一组约定或规范，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何编程对另一个线程可见，关键技术点都是围绕<strong>多线程的原子性、可见性和有序性展开的</strong>。</p>
<p><strong>JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</strong></p>
<ol>
<li><strong>通过JMM来实现线程和主内存之间的抽象关系</strong></li>
<li><strong>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果</strong>。</li>
</ol>
<h3 id="7-3-可见性"><a href="#7-3-可见性" class="headerlink" title="7.3 可见性"></a>7.3 可见性</h3><p><strong>可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更</strong>。</p>
<p>JMM规定了所有的变量都存储在主内存中。注意，主内存指的就是内存，不是缓存，也不是寄存器，也不是硬盘。下图左侧是具体的硬件情况，而右侧则是抽象出的模型。一个线程会有自己的一块内存空间，即本地内存，而且线程并不会直接操作主内存，而是会读取主内存的数据到本地内存，然后操作本地内存。最后为了可见性，本地修改完之后，立即将副本推送到主内存中修改数据。</p>
<p><strong>换句话说，主内存是各个线程共享的，而本地内存则是线程私有的。</strong></p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_005.png" alt="image-20220818104831550"></p>
<p><strong>系统主内存中共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“脏读”</strong>。因此，因为是高并发，所以如果对主内存加锁（一个线程的工作期间），显然这是不合理的，串行后的效率非常低。此时可对数据进行副本，保存到线程的私有内存中。所以<strong>每个线程都有自己的工作内存</strong>，线程自己的工作内存保存了该线程使用到的变量的主内存副本拷贝，<strong>线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行</strong>，而不能够直接读写主内存中的变量。<strong>不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</strong>。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_006.png" alt="image-20220818110339656"></p>
<p>显然，在本地内存修改后，如果没来得及更新主内存，就会出现丢失修改的情况。比如AB线程修改主内存数据D，均是加一操作。A修改了本地内存，但是还没及时更新主内存，此时B就读取了主内存中的数据（仍然为原始数据，不是A修改之后的），此时最终主内存中的数据只能是被加了一次。</p>
<p><strong>因此，可见性指的就是只要本地内存发生了修改，必须通知其他线程，数据发生了修改，读取主内存的数据是不对的，已经过时了，需要通知其他使用该数据的线程。可见性就是及时通知，修改及时可见。</strong></p>
<h3 id="7-4-原子性"><a href="#7-4-原子性" class="headerlink" title="7.4 原子性"></a>7.4 原子性</h3><p>指一个操作是不可打断的，即多线程环境下，操作不被其他线程干扰。</p>
<h3 id="7-5-有序性"><a href="#7-5-有序性" class="headerlink" title="7.5 有序性"></a>7.5 有序性</h3><blockquote>
<p>有序性是指：对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内存维持顺序化语义，即<strong>只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序</strong>。</p>
</blockquote>
<p>简单地说，有序性指的就是指令重排序。我们平时书写的只是Java代码，其编译后加载到内存中的字节码指令顺序不一定就是语句的顺序。</p>
<p>优缺点：</p>
<blockquote>
<p>JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p>
<p>但是指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致（即可能产生并发安全问题）。简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。</p>
</blockquote>
<p>从源码到最终执行示例图：</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_007.png" alt="image-20220818113039922"></p>
<p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性。</p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能够保证一致性是无法确定的，结果无法预测。<strong>所以在多线程环境下，应该根据业务慎重重排。</strong></p>
<p>案例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">12</span>;</span><br><span class="line">x = x + <span class="number">5</span>;</span><br><span class="line">y = x + x;</span><br></pre></td></tr></table></figure>

<p>显然第一行和第二行是可以重排的，但是第一行和第三行是不允许重排的，因为第三行显然是依赖第一行的数据的。</p>
<h3 id="7-6-多线程对变量的读写过程"><a href="#7-6-多线程对变量的读写过程" class="headerlink" title="7.6 多线程对变量的读写过程"></a>7.6 多线程对变量的读写过程</h3><p>这里针对可见性进行整理一下。读取过程如下：</p>
<blockquote>
<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存就是共享数据区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存存储着主内存中的变量拷贝副本，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_008.png" alt="image-20220818114412883"></p>
<p>多线程之间无法读取其他线程本地内存的数据，只能共享主内存中数据，即横向不打通，竖向共享主内存。那么在修改主内存之后，是如何通知其他线程主内存数据发生了改变呢？<strong>这里采用了总线嗅探机制，MESI缓存一致性协议。</strong></p>
<p>JMM定义了线程和主内存之间的抽象关系</p>
<ol>
<li>线程之间的共享变量存储在主内存中（从硬件角度来说就是内存条）</li>
<li>每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本（从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等等）</li>
</ol>
<p>小结：</p>
<ol>
<li>我们定义的所有共享变量都存储在物理主内存中</li>
<li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</li>
<li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行，然后写回主内存，不能直接从主内存中读写（不能越级）</li>
<li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）</li>
</ol>
<h3 id="7-7-多线程先行发生原则之happens-before"><a href="#7-7-多线程先行发生原则之happens-before" class="headerlink" title="7.7 多线程先行发生原则之happens-before"></a>7.7 多线程先行发生原则之happens-before</h3><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则。也就是逻辑上存在先后关系。</p>
<p>案例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span>;	<span class="comment">// 线程A执行</span></span><br><span class="line">y = x;	<span class="comment">// 线程B执行</span></span><br></pre></td></tr></table></figure>

<p>问题：y是否等于5呢？</p>
<blockquote>
<p>如果线程A的操作（x=5）happens-before（先行发生）线程B的操作（y=x），那么可以确定线程B执行后y=5一定成立；</p>
<p>如果他们不存在happens-before原则，那么y=5不一定成立。</p>
<p>这就是happens-before原则的威力，<strong>包含可见性和有序性的约束。</strong></p>
</blockquote>
<p>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都讲会变得非常啰嗦。但是我们没有时时、处处、次次添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下有一个“先行发生”（Happens-Before）的原则限制和规矩，已经立好了规矩。其实synchronized和volatile其实底层也是依据本原则的。</p>
<p><strong>这个原则非常重要：它是判断数据是否存在竞争、线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。</strong></p>
<h4 id="7-7-1-总原则"><a href="#7-7-1-总原则" class="headerlink" title="7.7.1 总原则"></a>7.7.1 总原则</h4><ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。<strong>注意，只有结果一致，重排才合法。</strong></li>
</ol>
<h4 id="7-7-2-八条原则"><a href="#7-7-2-八条原则" class="headerlink" title="7.7.2 八条原则"></a>7.7.2 八条原则</h4><p>这里从学术角度陈述happens-before的八条原则。</p>
<ol>
<li><p>次序规则</p>
<p>就是先来先到的原则。一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作。简单说就是，前一个操作的结果可以被后续的操作获取。就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道x已经变成1。</p>
</li>
<li><p>锁定规则</p>
<p>一个unLock操作先行发生于后面（<strong>这里的后面是指时间上的先后</strong>）对同一个锁的lock操作。换句话说，只有线程释放锁之后，其他线程才能获取到该锁。</p>
</li>
<li><p>volatile变量规则</p>
<p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，<strong>前面的写对后面的读是可见的</strong>。（<strong>这里的后面同样是指时间上的先后</strong>），就是说，只要写了，后面的读就会可见这个写后的结果。</p>
</li>
<li><p>传递规则</p>
<p>如果才做A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p>
</li>
<li><p>线程启动规则（Thread Start Rule）</p>
<p>Thread对象的start()方法先行发生于此线程的每一个操作，其实就是start方法就是线程的入口，一定是最先执行的。</p>
</li>
<li><p>线程中断规则（Thread Interruption Rule）</p>
<p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。可以通过Thread.interrupted()检测到是否发生中断。也就是说，要先调用interrupt()方法设置过中断标志位，才能检测到中断发送。</p>
</li>
<li><p>线程终止规则（Thread Termination Rule）</p>
<p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</p>
</li>
<li><p>对象终结规则（Finalizer Rule）</p>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</p>
</li>
</ol>
<h4 id="7-7-3-小结"><a href="#7-7-3-小结" class="headerlink" title="7.7.3 小结"></a>7.7.3 小结</h4><p>在Java语言里面，Happens-Before的语义本质上是一种可见性。A Happens-Before B意味着A发生过的事情对B来说是可见的，无论A事件和B事件是否发生在同一个线程里。</p>
<p>JMM的设计分为两部分：</p>
<ol>
<li>一部分是面向我们程序员提供的，也就是happens-before原则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了。</li>
<li>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提高性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序。我们只需要关注前者就好了，也就是理解happens-before规则即可，其他繁杂的内容有JMM规范结合操作系统给我们搞定，我们只写好代码即可。</li>
</ol>
<h2 id="8-volatile"><a href="#8-volatile" class="headerlink" title="8. volatile"></a>8. volatile</h2><p>volatile是一个修饰符，在高并发下经常使用。被volatile修饰的变量有两大特点：</p>
<ol>
<li>可见性</li>
<li>有序性（不再允许JVM自己重排，而是由程序员自己设置是否重排）</li>
</ol>
<p>参考上面JMM规范的三大特性，可知volatile不支持原子性。</p>
<p>volatile的具体含义如下：</p>
<ol>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量。</li>
<li>所以，<strong>volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从内存中读取</strong>。（即可见性）</li>
</ol>
<p>那么volatile是如何保证读写是直接写回和读取主内存呢（可见性），如何禁止重排呢（有序性）？<strong>通过内存屏障Memory Barrier。</strong></p>
<h3 id="8-1-内存屏障"><a href="#8-1-内存屏障" class="headerlink" title="8.1 内存屏障"></a>8.1 内存屏障</h3><p>回顾现实世界，屏障随处可见，比如高架桥上的两侧围栏、比如湖边的围栏等等。屏障就是为了保证安全，规范行为，使其有序（即禁止随意走动，重排）。</p>
<blockquote>
<p>内存屏障（也称内存栅栏，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，<strong>使得此点之前的所有读写操作都执行后，才可以开始执行此点之后的操作</strong>），避免代码重排序。</p>
<p>内存屏障其实就是一种JVM指令，Java内存模型的重排规则会<strong>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</strong>，通过内存屏障指令，volatile实现了Java内存模型中的可见性和有序性（禁重排），但volatile无法保证原子性。</p>
</blockquote>
<p>内存屏障是一个同步点，该点之前的所有写操作都要回写到主内存，该点之后的所有读操作就能获得内存屏障之前的所有写操作的最新结果。（实现了可见性）</p>
<ol>
<li>写屏障（Store Memory Barrier）：告诉处理器在写屏障之前将所有存储在缓存（store bufferes）中的数据同步到主内存。也就是说，当看到Store命令时，就必须把该指令之前所有写入指令执行完毕后才能继续向下执行。</li>
<li>读屏障（Load Memory Barrier）：告诉处理器在读屏障之后的读操作，都在读屏障之后执行（不允许重排到前面）。也就是说，在Load屏障指令之后就能保证后面的读取数据指令一定能够读取到最新的数据。【换句话说，本指令规定了不允许重排后的语句出现在读屏障之前，也就是说规定了重排序后的位置上限，而此时读屏障上面有写屏障，这就保证了下面的读操作一定是读取的最新数据】</li>
</ol>
<p>因此在重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。一句话：对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读。</p>
<h3 id="8-2-内存屏障分类"><a href="#8-2-内存屏障分类" class="headerlink" title="8.2 内存屏障分类"></a>8.2 内存屏障分类</h3><p>7.7节中的happens-before先行发生原则，类似接口规范，但是是怎么落地实现的呢？答案是：内存屏障。</p>
<p>粗略地说，内存屏障分为以下三种：</p>
<ol>
<li><p>读屏障（Load Barrier）</p>
<p><strong>在读指令之前，插入读屏障，让工作内存活CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据</strong>。</p>
</li>
<li><p>写屏障（Store Barrier）</p>
<p><strong>在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中</strong>。</p>
</li>
<li><p>全屏障（Full Barries）</p>
<p>上面两个的集合，即组合使用，从而达到有序性和可见性。</p>
</li>
</ol>
<p>详细地说，底层c++程序，内存屏障会分为四种：</p>
<ol>
<li>loadload</li>
<li>storestore</li>
<li>loadstore</li>
<li>storeload</li>
</ol>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_009.png" alt="image-20220818204145836"></p>
<p>上述四类屏障，保证了重排的范围，即屏障前后的重排不能跨过屏障。</p>
<h3 id="8-3-禁重排概述"><a href="#8-3-禁重排概述" class="headerlink" title="8.3 禁重排概述"></a>8.3 禁重排概述</h3><ol>
<li>重排序有可能影响程序的执行和实现，因此，我们有时候希望告诉JVM你别“自作聪明”给我重排序，我这里不需要排序，听主人的。</li>
<li>对于编译器的重排序，JMM会根据重排序的规则，禁止特定类型的编译器重排序。</li>
<li>对于处理器的重排序，Java编译器在生成指令序列的适当位置，插入内存屏障指令，来禁止特定类型的处理器排序。</li>
</ol>
<h3 id="8-4-happens-before之volatile变量规则"><a href="#8-4-happens-before之volatile变量规则" class="headerlink" title="8.4 happens-before之volatile变量规则"></a>8.4 happens-before之volatile变量规则</h3><p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_010.png" alt="image-20220818213550840"></p>
<ol>
<li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile<strong>读之后</strong>的操作不会被重排到volatile读之前。【对应图中篮框】</li>
<li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile<strong>写之前</strong>的操作不会被重排到volatile写之后。【对应图中红框】</li>
<li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。【对应紫圈】</li>
</ol>
<p>具体来说，Java中volatile是通过读写屏障实现的，如下所示：</p>
<ol>
<li><p>volatile读：</p>
<ol>
<li><p>在每个volatile读操作的后面插入一个LoadLoad屏障，禁止处理器把上面的volatile读与下面的普通读重排序。</p>
</li>
<li><p>在每个volatile读操作的后面插入一个LoadStore屏障，禁止处理器把上面的volatile读与下面的普通写重排序。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_012.png" alt="image-20220818215947875"></p>
</li>
</ol>
</li>
<li><p>volatile写：</p>
<ol>
<li><p>在每个volatile写操作的前面插入一个StoreStore屏障，可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。</p>
</li>
<li><p>在每个volatile写操作的后面插入一个StoreLoad屏障，作用是避免volatile写与后面可能有的volatile读/些操作重排序。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_011.png" alt="image-20220818215433738"></p>
</li>
</ol>
</li>
</ol>
<h3 id="8-5-保证可见性"><a href="#8-5-保证可见性" class="headerlink" title="8.5 保证可见性"></a>8.5 保证可见性</h3><p>可见性指的是不同线程对某个变量完成操作后对结果及时课件，即该共享变量一旦改变所有线程立即可见。</p>
<p>案例如下所示，需求：两个线程，A线程根据某共享变量进行循环，而B线程会修改共享变量，然后退出程序。此时共享变量如果没有volatile修饰的话，是无法保证可见性的。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest26</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t---&gt;come in&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">                <span class="comment">// 注意，循环体不能写sout输出语句，因为输出语句用到了sync，就会重新从主内存加载，即这是主动加载数据，并不是可见性主动通知的。</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t---&gt;flag被设置为false，程序停止&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程修改flag</span></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改完成，flag为：&quot;</span> + flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行程序，可以发现，此时子线程并没有停止，说明其读取的就是它的本地内存，而没有及时更新主内存。</span></span><br><span class="line">        <span class="comment">// 或者说，本线程修改数据后，没有刷新到主内存。</span></span><br><span class="line">        <span class="comment">// 不管那个，都是可见性没有保证。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将共享变量设置为volatile修饰，可以看到程序能够正常结束，子线程可以及时获取到最新的数据，从而正常结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest27</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量，volatile修饰</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t---&gt;come in&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(flag)&#123;&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t---&gt;flag被设置为false，程序停止&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程修改flag</span></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改完成，flag为：&quot;</span> + flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行程序，可以发现，主线程修改了flag之后，能够及时通知子线程。程序正常运行结束。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么子线程为什么看不到主线程main修改为false的flag的值呢？</p>
<p>问题可能：</p>
<ol>
<li>主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。</li>
<li>主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中更新获取flag最新的值。</li>
</ol>
<p>正常流程希望：</p>
<ol>
<li>线程中修改了自己工作内存中的副本之后，立即将其刷新到主内存。</li>
<li>工作内存中每次读取共享变量时，都去主内存中重新服务，然后拷贝到工作内存。</li>
</ol>
<p>解决方案：</p>
<ul>
<li>使用volatile修饰共享变量，就可以达到上面的效果，被volatile修饰的变量有以下特点：<ol>
<li>线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存。</li>
<li>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存。</li>
</ol>
</li>
</ul>
<p><strong>这里要注意，主内存中的数据，在修改的时候要加锁，保证并发安全。而且加锁后，会清空其他线程工作内存中该变量副本的值，在使用变量前必须重新load或assign。</strong></p>
<h3 id="8-6-JMM中的8个原子操作"><a href="#8-6-JMM中的8个原子操作" class="headerlink" title="8.6 JMM中的8个原子操作"></a>8.6 JMM中的8个原子操作</h3><p>工作内存和主内存之间的数据操作会涉及到几个原子操作。</p>
<ol>
<li>read：<strong>作用于主内存</strong>，将变量的值从主内存传输到工作内存，主内存到工作内存</li>
<li>load：作用于工作内存，将read从主内存传输的变量值放入到工作内存变量副本中，即数据加载</li>
<li>use：作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</li>
<li>assign：作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时就会执行该操作</li>
<li>store：作用于工作内存，将赋值完毕的工作变量的值写回给主内存</li>
<li>write：<strong>作用于主内存</strong>，将store传输过来的变量值赋值给主内存中的变量</li>
</ol>
<p>由于<strong>上述6条只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令</strong>：</p>
<ol start="7">
<li>lock：作用于主内存，将一个变量标记为一个线程独占的状态，<strong>只是写时候加锁，就只是锁了写变量的过程</strong>。</li>
<li>unlock：作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用。</li>
</ol>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_013.png" alt="image-20220818224726310"></p>
<h3 id="8-7-无原子性"><a href="#8-7-无原子性" class="headerlink" title="8.7 无原子性"></a>8.7 无原子性</h3><p>volatile不支持原子性，只有可见性和有序性。volatile变量的复合操作不具有原子性，比如number++。</p>
<p>以多线程对某个变量进行++操作，可以看到，在没有synchronized等锁修饰的前提下，无论对变量是否添加volatile修饰，都不能保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest28</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        MyNumber mn = <span class="keyword">new</span> MyNumber();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    mn.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(mn.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因分析：因为JMM只定义了8个原子操作，这里面的操作要么是加载读取，要么是存储写入等等。都没有涉及到运算。</p>
<p>而上面的++操作，因为底层涉及到获取变量值，然后加1，然后存储，此时，只能保证获取值和存储是原子操作，但是中间，任意线程都可操作。这时候，就相当于丢失修改。<strong>无论是不是复合操作，就算是基本的语句，也是无法保证原子性的。</strong>而可见性指的是在读取时一定是最新的，但是读取后，就无法保证再读取了。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_014.png" alt="image-20220819095238645"></p>
<p>而前面的用synchronized关键字修饰的情况，保证了从读取数据到写入数据整个过程都是加锁的，也就是上面图中，包括实线和虚线两部分，而不仅仅是实线。这就保证了整体原子性，从而保证不会被丢失修改。</p>
<p><strong>另外，synchronized保证的是从主内存中读取数据。</strong></p>
<p>那么volatile关键字的作用是什么呢？既然synchronized已经完全实现了全部功能。因为synchronized锁太重量级了，完全保证了主内存中的数据是不可见的。</p>
<p>虽然volatile没有保证原子性，但是能够实现可见性，因此对于共享变量，但是没有更新操作的情况还是比synchronized适合的。即<strong>volatile变量不合参与到依赖当前值的运算</strong>。</p>
<h3 id="8-8-指令禁重排"><a href="#8-8-指令禁重排" class="headerlink" title="8.8 指令禁重排"></a>8.8 指令禁重排</h3><p>重排序是指编译器和处理器为了优化性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序：</p>
<ol>
<li>不存在数据依赖关系，可以重排序；</li>
<li>存在数据依赖关系，禁止重排序；</li>
</ol>
<p>但重排后的指令绝对不能改变原有的串行语义！<strong>这点在并发设计中必须要重点考虑</strong>。</p>
<p><strong>数据依赖性是指：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性</strong>。</p>
<p>从 源代码到最终执行的指令序列中，需要有三次重排序。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_015.png" alt="image-20220819105036112"></p>
<p><strong>编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行，但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境</strong>。</p>
<p>此时可再回顾一下8.4中的规则，因为存在数据依赖性，所以加入屏障，所以也就不会重排序。</p>
<h3 id="8-9-总结"><a href="#8-9-总结" class="headerlink" title="8.9 总结"></a>8.9 总结</h3><p>volatile关键字保证了其修饰的变量在任何地方写的时候，都能够立即刷新回主内存中；在任何地方读的时候，都是读取的是主内存中的数据，保证了可见性。</p>
<p>另外，其修饰的变量在读写的时候都加入了内存屏障，禁止重排序，保证了部分线程安全。</p>
<p>但是没有保证针对该变量操作的原子性。</p>
<p>那么volatile应该使用在哪里呢？</p>
<ol>
<li>对于单一赋值的情况，是可以的。比如a=10这种。而a=a+10是不可的，a=b+10也是不可的。</li>
<li>对于状态标志，判断业务是否结束，根据flag是否为true来结束某个任务。</li>
<li>对于开销较低的读，也是可以的。比如读操作远多于写，写方法用synchronized修饰，而读方法可以不用synchronized修饰，在变量上直接用volatile修饰。</li>
<li>单例模式，DCL（Double Check Lock）双端锁的发布。</li>
</ol>
<p>在翻译底层字节码指令时，会在变量定义的时候，如果该变量是volatile修饰的，那么就会添加一个flags标志位，值为ACC_VOLATILE。</p>
<h2 id="9-CAS算法"><a href="#9-CAS算法" class="headerlink" title="9. CAS算法"></a>9. CAS算法</h2><p>CAS算法的实现，主要体现在java.util.concurrent.atomic包中，里面的原子类几乎都是CAS思想的落地实现。</p>
<p>前面的案例提到过，在多线程下，对于共享变量，如果不加synchronized，肯定会出现线程安全问题。而synchronized是比较重量级的，应该少用。但是volatile是无法保证的。<strong>可以直接使用atomic包中的数据类型，比如AtomicInteger，作为整型变量。</strong></p>
<p>除了AtomicInteger之外，还有AtomicBoolean等封装的基本数据类型。另外，还有AtomicReference&lt;T&gt;封装了引用数据类型。</p>
<h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><p>CAS是Compare And Swap的缩写，中文翻译成比较并交换，是实现并发算法时常用到的一种技术。它包含三个操作数——内存位置值（V）、预期原值（A）、更新值（B）。</p>
<ol>
<li>执行CAS操作的时候，将内存位置的值与预期原值比较</li>
<li>如果相匹配，那么处理器会自动将该位置更新为新值</li>
<li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作，只有一个会成功。</li>
</ol>
<p>当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来，这种重来重试的这种行为称为——自旋。<strong>注意，自旋就是再次执行这一个操作，即重新读取值，执行线程操作，写入数据。这样既避免了丢失修改，也保证了线程能够执行完成。（自旋锁）</strong></p>
<p><strong>就是说，在线程刚开始，肯定要先读取数据，即A，然后经过操作，修改为B，之后写入的时候，读取数值V，判断V和A是否一致。即判断是否有人修改过这个值。从而保证没有被人操作过数据。</strong></p>
<h3 id="9-2-CAS算法底层"><a href="#9-2-CAS算法底层" class="headerlink" title="9.2 CAS算法底层"></a>9.2 CAS算法底层</h3><p>CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。它是非阻塞的且自身具有原子性，也就是说这玩意效率更高且通过硬件保证，说明这玩意更可靠。</p>
<p><strong>CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg</strong>。</p>
<p>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行CAS操作，也就是说CAS的原子性实际上是CPU实现独占的，比如用synchronized重量级锁，这里的排他时间要短很多，所以在多线程情况下性能会比较好。</p>
<p>和内存屏障类似，AtomicInteger的相关操作底层仍然是Unsafe类实现的。换句话说，atomic包中都是CAS算法的落地实现，所以CAS的核心就是Unsafe类。</p>
<p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以向C的指针一个直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p>
<p>注意，Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都是直接调用操作系统底层资源执行相应任务。</p>
<h3 id="9-3-自旋锁SpinLock"><a href="#9-3-自旋锁SpinLock" class="headerlink" title="9.3 自旋锁SpinLock"></a>9.3 自旋锁SpinLock</h3><p>CAS是实现自旋锁的基础。自旋锁其实比较简单，就是旋转，采用循环的方式去获取锁，不会立即阻塞。自旋锁的好处就是不会阻塞，减少了线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
<p>自旋锁案例如下所示：<strong>本质上就是通过对属性赋值，判断是否等于原始值来进行是否赋值。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，原子引用对象，如果不是利用compareAndSet赋值，其余情况都是null</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自旋锁，如果原子引用是null，那么就赋值为thread。</span></span><br><span class="line">        <span class="comment">// 其实就是赋值，如果赋值失败，那么就一直循环请求判断</span></span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>, thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 以自旋锁形式获取锁</span></span><br><span class="line">            spinLockDemo.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟线程进行工作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 工作完之后，释放锁</span></span><br><span class="line">            spinLockDemo.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暂停500毫秒，保证A先启动，开始B线程启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 以自旋锁形式获取锁</span></span><br><span class="line">            spinLockDemo.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 工作完之后，释放锁</span></span><br><span class="line">            spinLockDemo.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-CAS算法缺点"><a href="#9-4-CAS算法缺点" class="headerlink" title="9.4 CAS算法缺点"></a>9.4 CAS算法缺点</h3><ol>
<li><p>循环时间长，开销很大</p>
<p>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p>
</li>
<li><p>ABA问题</p>
<p>CAS仅仅是在开始和最后写入的时候读取并判断二者是否相等。如果在此期间，有线程修改该值并又修改回原值，显然CAS会察觉不到。即并不是没有修改过数据。</p>
</li>
</ol>
<p>因此，要想解决ABA问题，可添加版本号，每次修改版本号都会强制自动加一。atomic包中的工具类如AtomicStampReference，也就是给引用添加了版本号。</p>
<h2 id="10-ThreadLocal"><a href="#10-ThreadLocal" class="headerlink" title="10. ThreadLocal"></a>10. ThreadLocal</h2><p>ThreadLocal也被称为线程局部变量，<strong>注意，这是一个变量</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the &#123;@code ThreadLocal&#125; instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。而不是仅在一个方法内，或者是在一个类中的某个属性，脱离了对象的概念</strong>。</p>
<p>简单地说，类似servlet中的应用域、会话域、请求域等等，这里的ThreadLocal可以看成是线程域（只不过这个线程域只能存放一个变量）。回顾在web项目中，经常在controller、service之间通过方法调用来传参，其实有些时候，如果方法传参不合适，可以采用ThreadLocal来存储，因为一般情况下，传参都是一次请求中用到，而一次请求就对应servlet中的一个线程。</p>
<p>在JMM以及JVM中提到过，JVM为每个线程都分配一块栈空间，对于共享变量，会将其拷贝一份到本地变量中。<strong>主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所需的副本的值，从而避免了线程安全问题。</strong>换句话说，给线程分配了本地变量副本，每个线程操作的都是自己空间的变量，此时在一定程度上，避免了线程安全问题。而如果没有拷贝空间的话，此时就会在主内存中加锁，串行访问，使得效果降低。</p>
<p>ThreadLocal可以看成是当前线程的一个局部变量，在线程中的任意时刻都可以使用，可以看成是打破了方法的作用域。并且ThreadLocal是存储在ThreadLocalMap中。</p>
<h3 id="10-1-Thread、ThreadGroup、ThreadLocal-lt-T-gt-、ThreadLocalMap"><a href="#10-1-Thread、ThreadGroup、ThreadLocal-lt-T-gt-、ThreadLocalMap" class="headerlink" title="10.1 Thread、ThreadGroup、ThreadLocal&lt;T&gt;、ThreadLocalMap"></a>10.1 Thread、ThreadGroup、ThreadLocal&lt;T&gt;、ThreadLocalMap</h3><p>前三者都是在<code>java.lang</code>包下。ThreadLocalMap是ThreadLocal的静态内部类。</p>
<h3 id="10-2-ThreadLocal"><a href="#10-2-ThreadLocal" class="headerlink" title="10.2 ThreadLocal"></a>10.2 ThreadLocal</h3><p><code>java.lang.ThreadLocal</code>类有一个构造方法，还有几个方法。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadLocal()</td>
<td>创建线程局部变量对象。</td>
</tr>
<tr>
<td>T get()</td>
<td>返回当前线程的此线程局部变量副本中的值</td>
</tr>
<tr>
<td>protected T initialValue()</td>
<td>返回此线程局部变量的当前线程的“初始值”</td>
</tr>
<tr>
<td>void remove()</td>
<td>删除此线程局部变量的当前线程值</td>
</tr>
<tr>
<td>void set(T value)</td>
<td>将此线程局部变量的当前线程副本设置为指定值。</td>
</tr>
<tr>
<td>static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</td>
<td>创建一个线程局部变量。【和第三个方法功能一样，一般不再使用第三个方法】</td>
</tr>
</tbody></table>
<p>注意，ThreadLocal对象不能用构造方法来创建，创建后的对象虽然不是null，但是get()方法是null，如果直接使用会报空指针异常。必须初始化，可以直接用第5个方法以初始化形式来创建对象。</p>
<p>ThreadLocal案例如下所示，注意，size只是为了验证结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 需求1：5个销售卖房子，集团高层值关心销售总量的准确统计数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需求2：5个销售卖完房子，各自独立销售额度，自己业绩按照提成走，分灶吃放，各个销售自己动手，丰衣足食。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest29</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        House house = <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 随机每个销售的销售额</span></span><br><span class="line">                <span class="keyword">int</span> size = <span class="keyword">new</span> Random().nextInt(<span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 销售房子</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    house.saleHouse();  <span class="comment">// 从共享变量中售卖房子</span></span><br><span class="line">                    house.saleVolumeByThreadLocal();    <span class="comment">// 从本地变量中售卖房子</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里不能用size，因为真实情况下，是不知道的，只能根据线程自己的操作来动态获取。只能采用线程本地变量</span></span><br><span class="line"><span class="comment">//                System.out.println(Thread.currentThread().getName() + &quot;销售卖出房子：&quot; + size);</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;销售卖出房子：&quot;</span> + house.saleVolume.get());</span><br><span class="line"></span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;共计卖出多少套：&quot;</span> + house.saleCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> saleCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        saleCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对需求2，设置ThreadLocal线程本地变量，每个线程独一份。</span></span><br><span class="line">    <span class="comment">// 设置初始化本地变量值为0</span></span><br><span class="line">    ThreadLocal&lt;Integer&gt; saleVolume = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleVolumeByThreadLocal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        saleVolume.set(saleVolume.get() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-案例分析"><a href="#10-3-案例分析" class="headerlink" title="10.3 案例分析"></a>10.3 案例分析</h3><p>上面的ThreadLocal案例有什么隐患呢？</p>
<p>线程的本地空间是有限的，尤其是在线程池中，而ThreadLocal本地变量是线程自带的，空间有限，在多线程复用的情况下，有可能会使得系统逻辑混乱，内存溢出。所以在使用完这个变量后，要及时remove掉该数据，即上面的第四个方法。</p>
<blockquote>
<p>阿里巴巴开发手册：必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally块进行回收。</p>
<p>尤其在线程池中，因为线程池中的线程是会复用的，如果该线程分配的每个任务都用到了ThreadLocal，而且该任务执行结束后，没有remove掉该变量【注意，执行任务的时候，ThreadLocal是线程本地变量，占用的是线程的空间】。显然随着线程的复用，也就是任务的分配，线程的可用空间就会越来越少。所以就会导致内存泄露，直至内存溢出。</p>
<p>注意：<strong>经过测试，如果不同任务是同一个对象，那么所有线程的ThreadLocal的内存地址是一样的。如果任务不是一个对象，那么ThreadLocal的内存地址就不同。</strong>【我认为，ThreadLocal在对象级别，感觉就是在主内存拷贝一份，复制到本地内存，但是此时该对象指的就是主内存的内存地址。】</p>
<p>另外，因为线程复用，所以不同的任务的初始值应该是一样的，但是由于线程复用了，导致当前任务的初始值是上一个任务的执行之后的结果。即逻辑发生混乱。</p>
</blockquote>
<p>修改后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机每个销售的销售额</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="keyword">new</span> Random().nextInt(<span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 销售房子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                house.saleHouse();  <span class="comment">// 从共享变量中售卖房子</span></span><br><span class="line">                house.saleVolumeByThreadLocal();    <span class="comment">// 从本地变量中售卖房子</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里不能用size，因为真实情况下，是不知道的，只能根据线程自己的操作来动态获取。只能采用线程本地变量</span></span><br><span class="line">            <span class="comment">//                System.out.println(Thread.currentThread().getName() + &quot;销售卖出房子：&quot; + size);</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;销售卖出房子：&quot;</span> + house.saleVolume.get());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 此刻，该任务已经执行结束，本地变量不需要了。后续没有该任务了。</span></span><br><span class="line">            <span class="comment">// remove掉该本地变量。</span></span><br><span class="line">            house.saleVolume.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存泄露的案例比较难实现，这里实现一个简单的业务逻辑混乱情况。10个任务，每个任务都是从0加到1，采用线程池，只有3个核心线程。显然，各个任务最开始的值，并不都是0，因为一个线程复用了，导致前面的任务结果影响了后面的任务结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest30</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10个任务分配到3个线程中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取到操作之前的值</span></span><br><span class="line">                    Integer beforeInt = myData.threadLocal.get();</span><br><span class="line">                    myData.add();</span><br><span class="line">                    Integer afterInt = myData.threadLocal.get();</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tbefore:&quot;</span> + beforeInt + <span class="string">&quot;\tafter:&quot;</span> + afterInt);</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_016.png" alt="image-20220819233015252"></p>
<p>为了保证在线程复用的情况下，各个任务之间互不干扰，需要及时remove掉本地变量。修改后的部分代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10个任务分配到3个线程中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(myData.threadLocal);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取到操作之前的值</span></span><br><span class="line">            Integer beforeInt = myData.threadLocal.get();</span><br><span class="line">            myData.add();</span><br><span class="line">            Integer afterInt = myData.threadLocal.get();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tbefore:&quot;</span> + beforeInt + <span class="string">&quot;\tafter:&quot;</span> + afterInt);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清空该值，使得是初始值</span></span><br><span class="line">            myData.threadLocal.remove();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-ThreadLocal源码分析"><a href="#10-4-ThreadLocal源码分析" class="headerlink" title="10.4 ThreadLocal源码分析"></a>10.4 ThreadLocal源码分析</h3><p>Thread的部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的threadLocal其实就是线程真正的本地变量，而该变量的数据类型就是ThreadLocal中的内部类ThreadLocalMap。</p>
<p>ThreadLocal的部分源码如下。ThreadLocal里面有ThreadLocalMap静态内部类，而ThreadLocalMap里面也有Entry静态内部类，该类继承了弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="comment">// 弱引用</span></span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal中的get方法源码如下。获取当前线程，然后调用getMap方法，获取到当前线程的thredLocals属性。如果thredLocals不是null，然后获取Entry，并判断是否为null，如果不为null，则返回具体存储的值。如果thredLocals为null或者Entry为null，那么就会创建一个ThreadLocal返回其初始值。【而初始值就是返回null】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化为null</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程，并获得ThreadLocal变量，如果有则直接赋值</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有，则创建并赋值</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以看到，其实ThreadLocal本地变量，也是key、value键值对，key就是thisThreadLocal对象。所以也就是说entry存储空间，一个ThreadLocal只有一份。</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// Entry数组，长度为16</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal中的set方法源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap.set</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，ThreadLocalMap就是一个以ThreadLocal实例为key，任意值为value的Entry对象。</p>
<p>当我们为threadLocal变量赋值的时候，实际上就是以当前theadLocal实例为key，值为value的Entry往这个threadLocalMap中存放。</p>
<p>因此说，ThreadLocal本质上并不存储值，而是通过该对象获取到ThreadLocalMap对象，然后在Map对象中存储&lt;threadLocal, value&gt;。</p>
</blockquote>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_017.png" alt="image-20220820105551438"></p>
<h3 id="10-5-ThreadLocal内存泄露"><a href="#10-5-ThreadLocal内存泄露" class="headerlink" title="10.5 ThreadLocal内存泄露"></a>10.5 ThreadLocal内存泄露</h3><p>内存泄漏：不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p>
<p>上面提到过，ThreadLocal本质上是ThreadLocalMap，而ThreadLocalMap底层则是Entry数组，Entry是内部类，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">// 调用弱引用的构造方法，创建一个弱引用指向ThreadLocal对象</span></span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map（以ThreadLocal为key），不过这是经过了两层包装的ThreadLocal对象：</p>
<ol>
<li>第一层包装是使用WeakReference&lt;ThreadLocal&lt;?&gt;&gt;将ThreadLocal对象变成一个弱引用的对象；</li>
<li>第二层包装是定义了一个专门的类Entry来扩展WeakReferen ce&lt;ThreadLocal&lt;?&gt;&gt;</li>
</ol>
<p>强软弱虚四个引用的关系如下图所示，软引用、弱引用和虚引用均继承强引用。强引用无论什么时候都不会被回收，软引用只有在内存不足引起垃圾回收的时候，才会被回收；弱引用是下一次垃圾回收的时候进行回收；虚引用则是一个附属信息，不会决定对象的生命周期，get()方法返回null，必须和ReferenceQueue联合使用，相当于一个监控的作用。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_018.png" alt="image-20220820120516235"></p>
<p>那么在存储的时候，为什么要将ThreadLocal对象封装成弱引用呢？如果不用会有什么后果呢？</p>
<blockquote>
<p>其实在JVM已经提到过，强引用只是在栈内存中的一个变量，而上面只是给ThreadLocal对象多了一个弱引用，要想ThreadLocal对象真正的在垃圾回收时消失，就必须使得原始的强引用丢失。只保留一个弱引用。</p>
<p>当方法执行完以后，栈帧销毁，即强引用就会消失，此时ThreadLocal对象就只有一个弱引用指向，这样的话，肯定在<strong>下次垃圾回收时</strong>就会回收这个ThreadLocal对象。<strong>因为，只要强引用消失，从业务逻辑上讲，其实就不会再使这个对象了，为了尽快地清除它，所以使用弱引用最合适。</strong></p>
<p>如果Entry中的key引用是强引用，显然就会导致key指向的ThreadLocal对象以及v指向的对象不能被gc回收，造成内存泄露。【因为，key是强引用，而外部已经不使用ThreadLocal对象了，即没用但是却回收不了】</p>
<p>如下所示，ThreadLocal对象被回收以后，key指向了null。但是我们知道，ThreadLocal本质上是存储在ThreadLocalMap中的Entry的，也就是ThreadLocalMap并没有消失，ThreadLocalMap中出现了key为null的Entry。而如果线程复用，显然ThreadLocalMap就会存储很多个任务的ThreadLocal，这时候Entry数组（table）就会被占满，而且占用的对象value也不会再被访问，因为key已经为null了。造成内存泄露。</p>
<p>因此，为了避免出现过多的null情况，当key为null的时候，之后，我们再次调用get、set、remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。<strong>即set方法中调用replaceStaleEntry方法来释放value。</strong></p>
<p>也就是说，弱引用不能百分百的保证内存不泄露，因为value必须我们调用方法时才会被清除。</p>
<p><strong>我们应该在不使用某个ThreadLocal对象后，手动调用remove方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程任务遗留下来的value值，造成bug。</strong></p>
<p>而ThreadLocal的remove方法，则是清除掉key和value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThraedLocal.remove()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap.remove()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_019.png" alt="image-20220820131738702"></p>
<h3 id="10-6-总结"><a href="#10-6-总结" class="headerlink" title="10.6 总结"></a>10.6 总结</h3><ol>
<li><p>ThreadLocal.withInitial();</p>
</li>
<li><p>建议把ThreadLocal修饰为static</p>
<p>阿里开发手册：因为ThreadLocal无法解决共享对象的更新问题。这个变量是针对一个线程内所有操作动向的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操纵这个变量。</p>
<p>ThreadLocal能实现了线程的数据隔离，不在于它自己本身，而在于Thread的ThreadLocalMap。所以，ThreadLocal可以只初始化一次，只分配一块存储空间就足以了，没必要作为成员变量多次被初始化。</p>
</li>
<li><p>用完记得手动remove</p>
</li>
</ol>
<p>另外：</p>
<ol>
<li>ThreadLocal并不解决线程间共享数据的问题</li>
<li>ThreadLocal适用于变量在线程间隔离且在方法间共享的场景</li>
<li>ThreadLocal通过隐式的在不同线程内创建独立实例副本，避免了实例线程安全的问题</li>
<li>每个线程持有一个只属于自己的专属Map，并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li>
<li>ThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题</li>
<li>都会通过expungeStaleEntry，cleanSomeSlots，replaceStaleEntry这三个方法回收键为null的Entry对象的值（即具体实例）以及Entry对象本身，从而防止内存泄露，属于安全加固的方法</li>
</ol>
<h2 id="11-AQS"><a href="#11-AQS" class="headerlink" title="11. AQS"></a>11. AQS</h2><p>AQS指的是AbstractQueuedSynchronizer的缩写，即抽象的队列同步器。AQS是JUC底层架构中的重点之重点。为什么加锁就能保证并发安全呢？底层就是AQS。存储未抢到锁的线程，并按照一定规则后续为其分配锁。因此：</p>
<ol>
<li><strong>锁，面向锁的使用者</strong>：定义了程序员和锁交互的使用层API，隐藏了实现细节，直接调用即可。</li>
<li><strong>同步器，面向锁的实现者</strong>：因为锁的种类有很多，但是锁的一些基本操作是相同的。因此Java并发大神DougLee，提出<strong>统一规范并简化了锁的实现</strong>，将其抽象出来屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等，是一切锁和同步组件实现的<strong>公共基础部分</strong>。</li>
</ol>
<p>因此，AQS可以存储阻塞的线程，并提供一种机制为阻塞的线程调度唤醒并分配锁资源。</p>
<h3 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h3><p>在java.util.concurrent.locs包中关于AQS有如下三个抽象类：</p>
<ol>
<li>AbstractOwnableSynchronizer</li>
<li>AbstractQueuedLongSynchronizer</li>
<li>AbstractQueuedSynchronizer</li>
</ol>
<p>其中下面的两个类均继承上面的类。AbstractQueuedSynchronizer和AbstractQueuedLongSynchronizer相当于孪生兄弟，只不过AbstractQueuedSynchronizer出现的更早，因此着重关注AbstractQueuedSynchronizer即可。</p>
<p>我们知道，锁资源是需要线程竞争的，那么当多线程情况下，必然出现抢不到的情况，那么这些线程该怎么办呢？销毁吗？显然是不行的，应该等待分配锁资源，此时他们就应该被放到一个等待队列中。<strong>那么如何在队列中放置这些线程呢？</strong>其实就是AQS。</p>
<blockquote>
<p>AQS是用来实现锁或者其他同步器组件的公共基础部分的抽象实现，是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给“谁”的问题。</p>
</blockquote>
<p>下面是AQS源码中的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on</span></span><br><span class="line"><span class="comment">first-in-first-out (FIFO) wait queues.  This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic &#123;@code int&#125; value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.  Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated &#123;@code int&#125; value manipulated using methods &#123;@link #getState&#125;, &#123;@link #setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect to synchronization.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>AQS依赖于FIFO等待队列，通过一个标志state来指明该线程是否获取锁或者释放锁。<strong>AQS整体就是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The wait queue is a variant of a <span class="string">&quot;CLH&quot;</span> (Craig, Landin, and</span><br><span class="line">Hagersten) lock queue. CLH locks are normally used <span class="keyword">for</span></span><br><span class="line">spinlocks.  <span class="function">We instead use them <span class="keyword">for</span> blocking synchronizers by including <span class="title">explicit</span> <span class="params">(<span class="string">&quot;prev&quot;</span> and <span class="string">&quot;next&quot;</span>)</span> links plus a &quot;status&quot; field that allow nodes to signal successors when releasing locks, and handle cancellation due to interrupts and timeouts. The status field includes bits that track whether a thread needs a <span class="title">signal</span> <span class="params">(using LockSupport.unpark)</span>. Despite these additions, we maintain most CLH locality properties.</span></span><br></pre></td></tr></table></figure>

<p>AQS中的CLH变体（虚拟双向队列）如下所示：</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_020.png" alt="image-20220821100453415"></p>
<p>前面所提到的一些类，比如ReentrantLock、CountDownLatch、Semaphore等底层都依赖于AQS。他们源码都有Sync内部类，该类继承了AbstractQueuedSynchronizer。部分类的继承实现关系图如下所示：</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_022.png" alt="image-20220821105031692"></p>
<p>我们知道，加锁就会导致阻塞，而有阻塞就需要排队，实现排队那必然需要队列。</p>
<h3 id="11-2-体系架构"><a href="#11-2-体系架构" class="headerlink" title="11.2 体系架构"></a>11.2 体系架构</h3><p>AQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。</p>
<p>整体上的结构如下所示：</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_021.png" alt="image-20220821104233671"></p>
<p>AQS部分源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可用于表示节点中的status取值，初始默认值为0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING   = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COND      = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类，抽象的，静态的节点</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为是双向队列，所以节点需要有前后指针</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        </span><br><span class="line">        Thread waiter;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// node节点的状态，即节点在队列中的状态</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 队列中的头尾节点指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面提到的state状态位</span></span><br><span class="line">    <span class="comment">// state为0，表示所代表的锁资源空闲，可以抢；&gt;=1表示被有人占用</span></span><br><span class="line">    <span class="comment">// 这里的&gt;=1，后面会涉及到可重用锁。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独占节点，表示以独占的方式等待锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclusiveNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享节点，表示以共享的模式等待锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3-源码分析"><a href="#11-3-源码分析" class="headerlink" title="11.3 源码分析"></a>11.3 源码分析</h3><p>Lock接口的实现类，基本都是通过<strong>聚合</strong>了一个队列同步器的子类完成线程访问控制的。以ReentrantLock类为例，深入底层AQS。ReentrantLock类实现了Lock接口，并且该类底层有一个Sync抽象类来实现锁功能的，而Sync又继承了AQS。ReentrantLock锁默认是非公平锁。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJava%5CJava_concurrent%5Cjuc_023.png" alt="image-20220821112738597"></p>
<p>ReentrantLock部分源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sync内部类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平锁内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公平锁内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相当于传入false，即非公平锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，lock和unlock方法底层都是调用的是Sync类中的方法。由于Sync类是抽象类，所以可分别查看NonfairSync类和FairSync类。以NonfairSync为例。</p>
<p>Sync类部分源码如下所示，其实Sync中并没有release方法，其实这里调用的是AQS中的release方法。initialTryLock和acquire方法也是，均是AQS中的方法，而acquire在AQS中实现了，底层调用的tryAcquire方法，仅仅抛出异常，并没有真正实现。而NonfairSync实现了这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">initialTryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果没有初步抢到，则进入acruqire()</span></span><br><span class="line">        <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">            <span class="comment">// 参数1表明抢锁成功，占用资源。这里只是再次尝试抢，并不是真正的抢到了，可看源码</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现了具体细节</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = (c == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// acquire没有初步抢到，这里再次尝试抢</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            <span class="comment">// 如果还没有抢到，只能进入队列。</span></span><br><span class="line">            <span class="comment">// 这里是重载了，具体实现可查看源码</span></span><br><span class="line">            acquire(<span class="keyword">null</span>, arg, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未实现具体细节</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            signalNext(head);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未实现具体细节</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初步抢</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initialTryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现了具体细节</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前锁资源为空，设置状态，并抢占成功，设置当前线程为资源拥有者</span></span><br><span class="line">        <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 抢锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其实这就是模板模式的体现，AQS中仅实现了最基本的方法以及框架，比如tryAcquire的实现就是仅抛出了异常，但是acquire就实现了具体的细节。模板模式就是实现一些必备的框架，但是具体的部分细节需要用户自定义实现。类似的有Servlet中的GenericServlet和HttpServlet中的doGet等方法。</strong></p>
<p>换句话说，ReentrantLock的本质框架仍然是AQS，只不过封装了lock、unlock方法，实现了tryAcquire的具体细节。</p>
<p>可查看FairSync源码，和NonfairSync类似，只不过多了一层hasQueuedThreads()判断，这个方法是公平锁加锁时判断等待队列中是否存在有效节点的方法。也就是说，公平锁需要判断是否前面有线程在等待，如果有，那么就加入队列等待。</p>
<ol>
<li>公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入到等待队列中；</li>
<li>非公平锁，不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程锁苏醒后，不一定就是排头的这个线程获得锁，它还是需要参加竞争锁（存在线程竞争的情况下），后来的线程可能不讲武德插队夺锁了。</li>
</ol>
<h3 id="11-4-Acquire方法"><a href="#11-4-Acquire方法" class="headerlink" title="11.4 Acquire方法"></a>11.4 Acquire方法</h3><p>前面可以看到，无论公平锁还是非公平锁，lock底层都是acquire。在JDK8中acquire分为三步【上面的源码是JDK11或15的，在JDK15中，虽然代码看起来公平锁也是直接抢了，但是它底层实现是有区别的，只是在是可重入锁或者等待队列是空的时候才抢的】：</p>
<ol>
<li><p>tryAcquire()</p>
<p>能抢到，则抢，抢不到则排队。</p>
</li>
<li><p>调用addWaiter()</p>
<p>抢锁失败，加入到等待者队列。</p>
</li>
<li><p>调用acquireQueued</p>
<p>在队列中，尝试抢锁</p>
</li>
</ol>
<h3 id="11-5-tryAcquire方法"><a href="#11-5-tryAcquire方法" class="headerlink" title="11.5 tryAcquire方法"></a>11.5 tryAcquire方法</h3><p>lock方法调用之后，先用initialTryLock尝试获取锁资源，如果失败，再通过tryAcquire尝试获取。如果还失败，那么只能入队了。</p>
<h3 id="11-6-addWaiter方法"><a href="#11-6-addWaiter方法" class="headerlink" title="11.6 addWaiter方法"></a>11.6 addWaiter方法</h3><p>JDK8的addWaiter就是JDK15中重载的acquire方法，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">acquire</span><span class="params">(Node node, <span class="keyword">int</span> arg, <span class="keyword">boolean</span> shared,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">boolean</span> interruptible, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">byte</span> spins = <span class="number">0</span>, postSpins = <span class="number">0</span>;   <span class="comment">// retries upon unpark of first thread</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>, first = <span class="keyword">false</span>;</span><br><span class="line">    Node pred = <span class="keyword">null</span>;                <span class="comment">// predecessor of node when enqueued</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Repeatedly:</span></span><br><span class="line"><span class="comment">         *  Check if node now first</span></span><br><span class="line"><span class="comment">         *    if so, ensure head stable, else ensure valid predecessor</span></span><br><span class="line"><span class="comment">         *  if node is first or not yet enqueued, try acquiring</span></span><br><span class="line"><span class="comment">         *  else if node not yet created, create it</span></span><br><span class="line"><span class="comment">         *  else if not yet enqueued, try once to enqueue</span></span><br><span class="line"><span class="comment">         *  else if woken from park, retry (up to postSpins times)</span></span><br><span class="line"><span class="comment">         *  else if WAITING status not set, set and retry</span></span><br><span class="line"><span class="comment">         *  else park and clear WAITING status, and check cancellation</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="keyword">null</span>) ? <span class="keyword">null</span> : node.prev) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !(first = (head == pred))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cleanQueue();           <span class="comment">// predecessor cancelled</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Thread.onSpinWait();    <span class="comment">// ensure serialization</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first || pred == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> acquired;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (shared)</span><br><span class="line">                    acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    acquired = tryAcquire(arg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                cancelAcquire(node, interrupted, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="keyword">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="keyword">null</span>;</span><br><span class="line">                    node.waiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;                 <span class="comment">// allocate; retry before enqueue</span></span><br><span class="line">            <span class="keyword">if</span> (shared)</span><br><span class="line">                node = <span class="keyword">new</span> SharedNode();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="keyword">new</span> ExclusiveNode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred == <span class="keyword">null</span>) &#123;          <span class="comment">// try to enqueue</span></span><br><span class="line">            node.waiter = current;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            node.setPrevRelaxed(t);         <span class="comment">// avoid unnecessary fence</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                tryInitializeHead();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node))</span><br><span class="line">                node.setPrevRelaxed(<span class="keyword">null</span>);  <span class="comment">// back out</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">            --spins;                        <span class="comment">// reduce unfairness on rewaits</span></span><br><span class="line">            Thread.onSpinWait();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">            node.status = WAITING;          <span class="comment">// enable signal and recheck</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos;</span><br><span class="line">            spins = postSpins = (<span class="keyword">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!timed)</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            node.clearStatus();</span><br><span class="line">            <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cancelAcquire(node, interrupted, interruptible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-7-acquireQueued方法"><a href="#11-7-acquireQueued方法" class="headerlink" title="11.7 acquireQueued方法"></a>11.7 acquireQueued方法</h3><p>队列中的线程对象（Node.waiter属性）如何被调度的呢？如何获取锁资源呢？其实还是在上面的那个方法中，只要入队一个线程，那么就把前一个节点（线程）的状态修改为waiting，表示可以唤醒，可以分配资源了。</p>
<p><code>LockSupport.park(this);</code>表示把当前线程挂起，等待资源分配。</p>
<p>只要有多余的线程进入，那么就会入队，就会循环（自旋锁），循环判断首节点以及是否可抢到资源，如果抢到，该线程就唤醒，然后删除原始节点，当前节点作为头节点。并且，在循环的过程中，也会判断当前节点所表示的线程是否已经cancel取消了操作，如果取消了，则将其从双向链表中删除。</p>
<h3 id="11-8-release方法"><a href="#11-8-release方法" class="headerlink" title="11.8 release方法"></a>11.8 release方法</h3><p>上面是线程排队进入AQS，挂起线程的流程。此时如果所需的锁资源释放掉了。也就是unlock，那么AQS队列中的线程如何分配资源呢？</p>
<p>前面已经知道了unlock底层是release方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        signalNext(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1-1=0</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = (c == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">// 设置资源拥有者为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置状态为0，表示没有占用</span></span><br><span class="line">    setState(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表明资源空闲</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">signalNext</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.waiter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码看的不是很懂，简单说一下。当锁被占用的时候，就会出现队列，头节点为null，后续跟着很多个线程节点，均挂起。当有线程释放锁之后，队列中的线程（第二个节点）就会被唤醒执行任务，此时头结点就会不被引用，被垃圾回收掉，而第二个节点因为线程已经在执行任务了，此时节点的waiter就被置为null，作为新的头节点。</p>
<h3 id="11-9-cancelAcquire方法"><a href="#11-9-cancelAcquire方法" class="headerlink" title="11.9 cancelAcquire方法"></a>11.9 cancelAcquire方法</h3><p>某个线程不想等待了，这时候就需要从队列中移除这个节点。</p>
<h3 id="11-10-总结"><a href="#11-10-总结" class="headerlink" title="11.10 总结"></a>11.10 总结</h3><p>其实可以看到，多线程加锁，本质上就是通过Lock对象来限制多线程对某块代码段的操作。如果有多个线程，此时就将多余的线程挂起，等待正在执行的线程释放锁之后，再合理地安排其他线程唤醒。</p>
<p>个人理解：公平锁和非公平锁，其实就是队列的首节点（线程）和现在刚刚到达的线程二者之间的抢占。但是队列中的线程，显然是无法参与抢占的。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">浮云</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://ihianian.github.io/2022/08/10/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-01-%E6%A6%82%E8%BF%B0/">https://ihianian.github.io/2022/08/10/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-01-%E6%A6%82%E8%BF%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">浮云</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JUC/">
                                    <span class="chip bg-color">JUC</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/null" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/null" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/08/11/%E7%A7%8B%E6%8B%9B-Servlet%E6%A6%82%E8%BF%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="秋招_Servlet概述">
                        
                        <span class="card-title">秋招_Servlet概述</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-08-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            浮云
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%A7%8B%E6%8B%9B/">
                        <span class="chip bg-color">秋招</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/08/06/%E7%A7%8B%E6%8B%9B-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="秋招-数据库概述">
                        
                        <span class="card-title">秋招-数据库概述</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-08-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            浮云
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%A7%8B%E6%8B%9B/">
                        <span class="chip bg-color">秋招</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2023</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">hianian</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">600.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">














    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
