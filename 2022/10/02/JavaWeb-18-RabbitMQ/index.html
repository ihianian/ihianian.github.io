<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JavaWeb_18_RabbitMQ, ihianian">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JavaWeb_18_RabbitMQ | ihianian</title>
    <link rel="icon" type="image/png" href="/header.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/header.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ihianian</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/404" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/404" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/header.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ihianian</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/404" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/404" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JavaWeb_18_RabbitMQ</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JavaWeb/">
                                <span class="chip bg-color">JavaWeb</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-10-02
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-10-24
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    52 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>本文介绍RabbitMQ。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>MQ（Message Queue），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是Message而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。消息处理下游也只需要依赖MQ获取消息（任务）即可。</p>
<h3 id="1-1-MQ的作用"><a href="#1-1-MQ的作用" class="headerlink" title="1.1 MQ的作用"></a>1.1 MQ的作用</h3><ol>
<li><p>流量削峰</p>
<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使<strong>用消息队列做缓冲，我们可以取消这个限制</strong>，把一秒内下的订单分散成一段时间来处理，这是有些用户可能在下单十几秒后才能收到下单成功的操作，虽然时间响应变慢了，但是比不能下单的体验更好。</p>
</li>
<li><p>应用解耦</p>
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修改。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中间用户感受不到物流系统的故障，提升系统的可用性。<strong>本质上就是消息队列作为缓存，作为一个代理，存储了中间结果，降低了流程处理过程。</strong></p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_001.png" alt="image-20221003150524169"></p>
</li>
<li><p>异步处理</p>
<p>有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询API查询。或者A提供一个callback api，B执行完之后调用api通知A服务。这两种方式都不是很优雅，使用消息队列，可以很方便解决这个问题，A调用B服务后，只需要监听B处理完成的消息，<strong>当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务</strong>。这样A服务既不用循环调用B的查询API，也不会提供callback api。同样B服务也不用做这些操作。A服务还能及时地得到异步处理成功的消息。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_002.png" alt="image-20221003151141797"></p>
</li>
</ol>
<h3 id="1-2-MQ分类"><a href="#1-2-MQ分类" class="headerlink" title="1.2 MQ分类"></a>1.2 MQ分类</h3><ol>
<li><p>ActiveMQ</p>
<p>比较久远的，单击吞吐量较高，时效性是毫秒级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据（丢失概率较低）。目前维护较少了。</p>
</li>
<li><p>Kafka</p>
<p>大数据的杀手锏，数据量较大适合使用。缺点是Kafka单击超过64个时，发送消息响应时间变长。会丢失消息。</p>
</li>
<li><p>RocketMQ</p>
<p>是阿里的开源产品，采用Java语言实现，在设计时参考了Kafka，单击吞吐量较高。消息可以做到0丢失。但是支持的客户端语言不多，仅Java和C++。</p>
</li>
<li><p>RabbitMQ</p>
<p>是一个在AMQP（高级消息队列协议）基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。健壮稳定跨平台。基于Erlang语言开发。</p>
</li>
</ol>
<h3 id="1-3-MQ的选择"><a href="#1-3-MQ的选择" class="headerlink" title="1.3 MQ的选择"></a>1.3 MQ的选择</h3><ol>
<li><p>Kafka</p>
<p>适合产生大量数据的业务，大型公司，如果有日志采集功能，首选Kafka。</p>
</li>
<li><p>RocketMQ</p>
<p>适合金融互联网领域，稳定性较好，适合双十一这种情况。</p>
</li>
<li><p>RabbitMQ</p>
<p>时效性微秒级，如果数据量不太大，且中小型公司，适合使用。</p>
</li>
</ol>
<h3 id="1-4-RabbitMQ介绍"><a href="#1-4-RabbitMQ介绍" class="headerlink" title="1.4 RabbitMQ介绍"></a>1.4 RabbitMQ介绍</h3><p>RabbitMQ是一个消息中间件：它接受并转发消息。可以把它当做一个快递站点，当你要发送一个包裹时，就需要将包裹放到快递站，快递员最终会把快递送到收件人那里。按照这种逻辑RabbitMQ是一个快递站，帮我们处理快递。RabbitMQ与快递站的主要区别在于，它不处理快件而是接受、存储和转发消息任务数据。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_003.png" alt="image-20221003153916852"></p>
<p>RabbitMQ有如下四个核心概念：</p>
<ol>
<li><p>生产者</p>
<p>产生数据发送消息的程序是生产者</p>
</li>
<li><p>交换机</p>
<p>交换机是RabbitMQ非常重要的一个部件，一方面他接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理他接收到的消息，是将这些消息推送到特定队列还是推动到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定。</p>
</li>
<li><p>队列</p>
<p>队列是RabbitMQ内部使用的一种数据结构，尽管消息流经RabbitMQ和应用程序，但他们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。</p>
</li>
<li><p>消费者</p>
<p>消费者与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者、消费者和消息中间件很多时候并不在同一个机器上。同一个应用程序既可以是生产者又可以是消费者。</p>
</li>
</ol>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_004.png" alt="image-20221003154219830"></p>
<h3 id="1-5-RabbitMQ的核心模式"><a href="#1-5-RabbitMQ的核心模式" class="headerlink" title="1.5 RabbitMQ的核心模式"></a>1.5 RabbitMQ的核心模式</h3><ol>
<li>Hello World</li>
<li>Work Queues</li>
<li>Publish/Subscribe</li>
<li>Routing</li>
<li>Topics</li>
<li>Publisher Confirms</li>
</ol>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_005.png" alt="image-20221003163431829"></p>
<ol>
<li>Broker：消息实体，是接收和分发消息的应用，RabbitMQ Server 就是Message Broker。Exchange是交换机，Queue是队列。</li>
<li>Virtual host：一个Broker中可以存在多个Virtual host，每个vhost可以包括多个excahnge。</li>
<li>Connection：生产者/消费者 和 Broker 之间的TCP连接。</li>
<li>Channel：信道，每一个访问RabbirMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。<strong>Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯</strong>，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP Connection的开销。</li>
<li>Exchange：交换机，message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct（point-to-point）、topic（publish-subscribe）、fanout（multicast）。</li>
<li>Queue：消息最终被送到这里等待消费者取走</li>
<li>Binding：exchange和queue之间的虚拟连接，binding中可以包含routing key，Binding信息被保存到exchange中的查询表中，用于message的分发依据。</li>
</ol>
<h3 id="1-6-安装"><a href="#1-6-安装" class="headerlink" title="1.6 安装"></a>1.6 安装</h3><p>目前在本地安装，简单学习一下。</p>
<p>由于RabbitMQ基于Erlang语言开发，所以必须要有Erlang环境。为了使用方便，可安装RabbitMQ的一个web管理插件。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tirster/article/details/121938987">【Windows安装RabbitMQ详细教程】_慕之寒的博客-CSDN博客_rabbitmq安装windows</a></p>
<p>注意，如果用户名是中文的话，其日志是有问题的，所以启动也会失败，因此需要修改日志存放位置，不能出现中文。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sitr/p/13992078.html">RabbitMQ启动失败！？原因竟是…… - Sitr-金融摸鱼哥 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.likecs.com/show-203290310.html?sc=509">RabbitMQ Management打不开的问题 - 爱码网 (likecs.com)</a></p>
<h2 id="2-核心部分（模式）"><a href="#2-核心部分（模式）" class="headerlink" title="2. 核心部分（模式）"></a>2. 核心部分（模式）</h2><p>在安装好RabbitMQ之后，下面对主流的各种模式进行代码演示。创建普通maven工程即可。注意需要添加jdk的编译版本插件以及rabbitmq的依赖和操作文件流的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- rabbitmq客户端依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 文件IO流依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-Hello-World简单队列模式"><a href="#2-1-Hello-World简单队列模式" class="headerlink" title="2.1 Hello World简单队列模式"></a>2.1 Hello World简单队列模式</h3><p>这种模式其实就是生产者消费者模式。需要有生产者给队列（hello），然后队列将消息转发给消费者（消费者接收消息）。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_006.png" alt="image-20221003185727443"></p>
<h4 id="2-1-1-生产者代码"><a href="#2-1-1-生产者代码" class="headerlink" title="2.1.1 生产者代码"></a>2.1.1 生产者代码</h4><p>其实这里的生产者需要编写的代码和1.5中的原理图类似，</p>
<ol>
<li>需要有逻辑连接Connection；</li>
<li>然后需要有具体的信道Channel；</li>
<li>当然，创建逻辑连接，除了生产者自身之外，还要有消息队列，即连接工厂，指明具体的消息队列IP以及用户名和密码；</li>
<li>在消息队列中需要有Broker（交换机和队列），由于是简单模式，因此这里省略交换机，只有一个队列，因此Channel发送消息前需要设定一些规则，比如交换机，队列。这里声明队列的名称QUEUE_NAME，并指明一些其他参数。</li>
<li>运行程序即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义常量，表示消息队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置工厂的IP，因为需要连接RabbitMQ队列，这里就是RabbitMQ服务器的IP</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        factory.setPort(AMQP.PROTOCOL.PORT);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置用户名密码</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接（逻辑连接Connection）</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据连接或者到信道（物理连接channel）</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用信道连接Broker【这里是入门程序，交换机可以省略，直接连接队列】</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数：</span></span><br><span class="line"><span class="comment">         *      1. 队列名称</span></span><br><span class="line"><span class="comment">         *      2. 队列里面的消息是否持久化（磁盘中，默认是在内存中，且不会持久化）</span></span><br><span class="line"><span class="comment">         *      3. 该队列是否只供一个消费者进行消费，是否进行消息的共享。true表示可以多个消费者消费，反之只允许一个消费者消费，默认是false</span></span><br><span class="line"><span class="comment">         *      4. 是否自动删除，即最后一个消费者断开连接后，该队列是否自动删除</span></span><br><span class="line"><span class="comment">         *      5. 其他参数，如关于延迟消息，死信消息等。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者发送消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息，参数：</span></span><br><span class="line"><span class="comment">         *      1. 发送到哪个交换机，本次没有，直接是空字符串即可 &quot;&quot;</span></span><br><span class="line"><span class="comment">         *      2. 路由的Key值是哪个，本次是队列的名称</span></span><br><span class="line"><span class="comment">         *      3. 其他参数信息</span></span><br><span class="line"><span class="comment">         *      4. 发送消息的消息体，即真正的消息内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行完程序后，可从后端RabbitMQ管理页面中发现，消息队列中确实有一个消息准备好了，也就是说生产者确实将消息发送到了消息队列中。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_007.png" alt="image-20221003203909673"></p>
<h4 id="2-1-2-消费者代码"><a href="#2-1-2-消费者代码" class="headerlink" title="2.1.2 消费者代码"></a>2.1.2 消费者代码</h4><p>其实消费者和生产者类似，同样需要创建连接和信道，最终消费消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的名称，这里和生产者要保持一致，因为生产者是将消息放到了该队列中，消费者要想获取到对应的消息，必须到该队列中取</span></span><br><span class="line">    <span class="comment">// 定义常量，表示消息队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息</span></span><br><span class="line">    <span class="comment">// 前提创建连接的步骤是一样的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息，参数</span></span><br><span class="line"><span class="comment">         *      1. 消费哪个队列，队列名称</span></span><br><span class="line"><span class="comment">         *      2. 消费成功之后是否要自动应答，true代表自动应答，false表示手动应答</span></span><br><span class="line"><span class="comment">         *      3. 消费者成功消费的回调：即消费成功的一个操作</span></span><br><span class="line"><span class="comment">         *      4. 消费者取消消费的回调。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 得到消息体</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，确认消息队列中的消息被消费了。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_008.png" alt="image-20221003210416865"></p>
<h3 id="2-2-Work-Queues工作队列模式"><a href="#2-2-Work-Queues工作队列模式" class="headerlink" title="2.2 Work Queues工作队列模式"></a>2.2 Work Queues工作队列模式</h3><p>工作队列（又称任务队列）的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程（消费者）将弹出任务（消费）并最终执行任务。当有多个工作线程（多个消费者）时，这些工作线程将一起处理这些任务。</p>
<p>简单地说，工作队列模式就是一个生产者多个消费者。<strong>但是任务队列中的任务只能被某个消费者消费一次，不能被处理多次，否则业务逻辑出现问题。</strong>因此，队列在分发任务的时候，实际上是轮询分发。</p>
<h4 id="2-2-1-案例"><a href="#2-2-1-案例" class="headerlink" title="2.2.1 案例"></a>2.2.1 案例</h4><p>代码演示，<strong>一个生产者，两个消费者。</strong>为了简单起见，将创建逻辑连接和信道的代码抽取成工具类。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接（逻辑连接Connection）</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据连接或者到信道（物理连接channel）</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码和上面的类似，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="comment">// 接收消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 得到消息体</span></span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息，消费后的操作就是上面的deliverCallback回调函数。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;W1等待接收消息...&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个消费者，其实代码是一样的，为了开启多个消费者（多个进程），这里采用IDEA提供的设置，先运行本程序，然后点开运行配置，勾选右上角允许并行运行即可再次运行。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_009.png" alt="image-20221003215742117"></p>
<p>生产者采用循环输入的方式发送消息。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">// 利用信道连接Broker【这里是入门程序，交换机可以省略，直接连接队列】</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数：</span></span><br><span class="line"><span class="comment">         *      1. 队列名称</span></span><br><span class="line"><span class="comment">         *      2. 队列里面的消息是否持久化（磁盘中，默认是在内存中，且不会持久化）</span></span><br><span class="line"><span class="comment">         *      3. 该队列是否只供一个消费者进行消费，是否进行消息的共享。true表示可以多个消费者消费，反之只允许一个消费者消费，默认是false</span></span><br><span class="line"><span class="comment">         *      4. 是否自动删除，即最后一个消费者断开连接后，该队列是否自动删除</span></span><br><span class="line"><span class="comment">         *      5. 其他参数，如关于延迟消息，死信消息等。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者发送消息</span></span><br><span class="line">        String message;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext()) &#123;</span><br><span class="line">            message = scanner.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 发送一个消息，参数：</span></span><br><span class="line"><span class="comment">             *      1. 发送到哪个交换机，本次没有，直接是空字符串即可 &quot;&quot;</span></span><br><span class="line"><span class="comment">             *      2. 路由的Key值是哪个，本次是队列的名称</span></span><br><span class="line"><span class="comment">             *      3. 其他参数信息</span></span><br><span class="line"><span class="comment">             *      4. 发送消息的消息体，即真正的消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(message + <span class="string">&quot; 发送完成&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行生产者，在控制台输入以下内容。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_010.png" alt="image-20221003224723147"></p>
<p>可以看到两个消费者确实是轮询消费了消息。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_011.png" alt="image-20221003224759518"></p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_012.png" alt="image-20221003224825189"></p>
<h4 id="2-2-2-消息应答问题"><a href="#2-2-2-消息应答问题" class="headerlink" title="2.2.2 消息应答问题"></a>2.2.2 消息应答问题</h4><blockquote>
<p>上面只是最基本的情况。但是这里存在一个问题。</p>
<p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个厂的任务并且仅只完成了部分，突然就挂掉了，会发生什么情况呢？</p>
<p>RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，如果某个消费者挂掉了，我们将丢失正在处理的消息。<strong>因此，为了保证消息已经被处理完，必须在处理完之后由消费者给予应答回复。</strong></p>
<p>为了保证消息在发送过程中不丢失，RabbitMQ引入消息应答机制：消费者在接收到消息并且处理该消息之后，告诉RabbitMQ它已经处理了，RabbitMQ就可以把该消息删除了。</p>
</blockquote>
<p>消息应答机制分为自动应答和手动应答。</p>
<h4 id="2-2-3-自动应答"><a href="#2-2-3-自动应答" class="headerlink" title="2.2.3 自动应答"></a>2.2.3 自动应答</h4><p>消息发送后立即被认为已经传送成功【显然这其实就是没应答，是不是那么靠谱的】，这种模式需要在高吞吐量和数据传输安全性方面做权衡。</p>
<p>其实这并没有应答，因为如果消费者Connection或者Channel如谈关闭，那么消息就丢失了；或者生产者产生的消息太多，导致消费者来不及处理消息，即消息积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>
<p><strong>自动应答就是消息发送后就是成功了。</strong></p>
<h4 id="2-2-4-手动应答"><a href="#2-2-4-手动应答" class="headerlink" title="2.2.4 手动应答"></a>2.2.4 手动应答</h4><p><strong>手动应答是由消费者主动通知消息队列</strong>。有如下几种应答方式：</p>
<ol>
<li><p>Channel.basicAck()</p>
<p>表示消息肯定处理成功了。</p>
</li>
<li><p>Channel.basicNack()</p>
<p>表示消息不确定处理成功了。</p>
</li>
<li><p>Channel.basicReject()</p>
<p>表示消息不确定处理成功了。</p>
</li>
</ol>
<h4 id="2-2-5-消息自动重新入队"><a href="#2-2-5-消息自动重新入队" class="headerlink" title="2.2.5 消息自动重新入队"></a>2.2.5 消息自动重新入队</h4><p>如果消费者由于某些原因失去连接（其通道已关闭，连接已关闭或TCP连接丢失），导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>
<p><strong>注意，因为存在回调函数，即获取到消息之后的消费者的操作。因此可在消费者中进行消息应答。</strong></p>
<p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        String message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(s.hasNext()) &#123;</span><br><span class="line">            message = s.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息发送</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码，这里要测试不同消费者场景，因此这里写两个消费者，一个消费者处理较快，一个处理较慢。这里仅展示一个，另一个只需要修改sleep时间即可。<strong>注意，应答是在回调函数中写的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;W1等待接收消息，处理时间较短&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 沉睡，模拟消息处理过程，时间较短，处理速度较快。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到消息体</span></span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 应答参数：</span></span><br><span class="line"><span class="comment">             *      1. 消息的标记 tag，即针对哪个消息应答</span></span><br><span class="line"><span class="comment">             *      2. 是否批量应答</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，如果队列不存在，那么必须先让生产者运行（声明队列），否则先开启消费者会报错，因为消费者仅仅是从队列中取消息，如果队列不存在，当然会报错。</strong></p>
<p>因为work2的工作时间较长，可在工作过程中手动停止程序（模拟挂掉），可以看到消息又重新转发到work1中。即手动确认实现了消息不丢失。</p>
<h4 id="2-2-6-RabbitMQ持久化"><a href="#2-2-6-RabbitMQ持久化" class="headerlink" title="2.2.6 RabbitMQ持久化"></a>2.2.6 RabbitMQ持久化</h4><p>上面仅仅保证了消费者宕机后消息可以不丢失。但是如何保证RabbitMQ服务挂掉后消息不丢失呢？默认情况下，RabbitMQ退出或由于某种原因崩溃时，它忽视队列和消息。<strong>为了确保消息不会丢失需要做两件事：将队列和消息都标记为持久化</strong>。</p>
<p>注意，队列是RabbitMQ中的组件，消息是消息，二者不是一体的，需要分别持久化。</p>
<ol>
<li><p>队列实现持久化</p>
<p>直接在声明队列时，将第二个参数改为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>但是，如果直接将已经存在的队列修改为true，会报错，此时必须先将该队列删除，再重新创建。持久化的队列会被标记为D。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg &#x27;durable&#x27; for queue &#x27;ack_queue&#x27; in vhost &#x27;/&#x27;: received &#x27;true&#x27; but current is &#x27;false&#x27;, class-id=50, method-id=10)</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_013.png" alt="image-20221004105721677"></p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_014.png" alt="image-20221004110206557"></p>
</li>
<li><p>消息持久化</p>
<p>在发布消息的第三个参数中设置<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code>。这种方式其实并不能完全保证不会丢失消息。尽管他告诉了RabbitMQ将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候，但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单队列任务而言，已经绰绰有余了。如果需要更强有力的持久化策略，见后续的<strong>发布确认模式</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(&quot;&quot;, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-2-7-不公平分发"><a href="#2-2-7-不公平分发" class="headerlink" title="2.2.7 不公平分发"></a>2.2.7 不公平分发</h4><p>上面只是最基本的轮询分发，但是在测试中可以发现，对于处理速度比较慢的消费者，显然也会分配指定数量的消息，这时候，<strong>处理速度比较快的消费者会处于空闲状态。其实为了综合考虑效率，应该采用不公平分发，速度快的分发多一点</strong>。</p>
<p><strong>可在消费者消费语句之前采用信道channel设置，0表示轮询，1表示不公平分发</strong>。<strong>其实就是表明本消费者可以采用不公平分发。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-8-预取值（prefetch）"><a href="#2-2-8-预取值（prefetch）" class="headerlink" title="2.2.8 预取值（prefetch）"></a>2.2.8 预取值（prefetch）</h4><p>不再是轮询或者不公平分发，而是指定每个消费者被分发的数量。同样和不公平分发一样设置，非0非1表示具体的预取值的数量。（或者说，这是消费者消息堆积的最大值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Publish-Subscribe发布订阅模式"><a href="#2-3-Publish-Subscribe发布订阅模式" class="headerlink" title="2.3 Publish/Subscribe发布订阅模式"></a>2.3 Publish/Subscribe发布订阅模式</h3><p>上面的两种模式中的消息都是只能发送给一个消费者。有时候需要<strong>将消息发送给多个消费者</strong>，这就是<strong>发布订阅模式</strong>。发布订阅模式需要用到交换机，参见2.7节。即<strong>由交换机将消息转发到不同的队列中，队列中的消息只能被消费一次，这样多个队列达到了多次消费</strong>。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_016.png" alt="image-20221004155931038"></p>
<p>发布订阅模式就是交换机采用fanout方式，即交换机将消息无差别的传送到多个队列中。本质上就是广播，所以生产者以及所有消费者，在绑定以及发布消息时的routingkey是任意的。</p>
<p><strong>注意，交换机在生产者还是在消费者中声明都是可以的，可以声明两次，也可以声明一次。但是声明的名称一定要一致，并且类型也要一致。如果名称不一致，显然不会正确接收；如果名称一致，类型不一致，则会报错。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里声明交换机，不采用自带的交换机。参数是 交换机名称、类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        String message;</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext()) &#123;</span><br><span class="line">            message = scanner.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意，这里因为是交换机和队列绑定了，所以第一个参数写交换机名称，第二个参数写routingkey</span></span><br><span class="line">            <span class="comment">// 由于是fanout模式，所以说，routingkey可以是任意值，无需和消费者绑定的一样。</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;hj&quot;</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里声明交换机，不采用自带的交换机。参数是 交换机名称、类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个临时队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将交换机与队列捆绑binding，参数是 队列名称，交换机名称，routingkey</span></span><br><span class="line">        <span class="comment">// 因为是fanout，所以routingkey任意</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ReceiveLogs01等待接收消息，把接收到的消息打印在屏幕上。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 得到消息体</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里声明交换机，不采用自带的交换机。参数是 交换机名称、类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个临时队列，注意，这里是两个消费者，分别与同一个交换机绑定。</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将交换机与队列捆绑binding，参数是 队列名称，交换机名称，routingkey</span></span><br><span class="line">        <span class="comment">// 因为是fanout，所以routingkey任意</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ReceiveLogs02等待接收消息，把接收到的消息打印在屏幕上。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 得到消息体</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-路由模式"><a href="#2-4-路由模式" class="headerlink" title="2.4 路由模式"></a>2.4 路由模式</h3><p><strong>路由模式就是根据规则来路由到指定的消费者队列中，不再像广播一样无差别发送。如果有多个队列绑定规则一样，也是可以接收到的</strong>，路由模式和广播模式的区别是按照一定的绑定规则发送和接收。这里代码不再赘述，和上面类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-5-主题模式"><a href="#2-5-主题模式" class="headerlink" title="2.5 主题模式"></a>2.5 主题模式</h3><p>发布订阅模式，是所有的消费者都可以收到。路由模式，是指定的消费者可以收到。但是，<strong>这两种都是固定死的，不能动态的指定消费者。</strong></p>
<p>此时，有这么一种需求，对于某些信息，发送给某几个消费者；对于另外其余信息，发送给某个消费者。<strong>即消费者不是固定的，此时就需要主题模式了，通过正则表达式模糊匹配绑定规则来发送到指定的队列中。</strong>如下图所示，如果仅想要Q1收到，那么中间单词必须是orange，且第一个单词不能是lazy，最后一个单词不能是rabbit。如果想要Q1、Q2同时收到，后两个单词只要是orange.rabbit即可，或者前两个单词是lazy.orange。</p>
<p><code>#</code>代表任意个单词，<code>*</code>表示1个单词。当一个队列的绑定键（routingkey）是<code>#</code>，那么就类似fanout模式了；如果队列绑定建中没有<code>#</code>和<code>*</code>，那么就类似direct模式了。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_019.png" alt="image-20221004190421535"></p>
<h3 id="2-6-发布确认"><a href="#2-6-发布确认" class="headerlink" title="2.6 发布确认"></a>2.6 发布确认</h3><p>2.2.6中的持久化提到过，当时的方式并不能完全保证持久化，因为生产者到消息队列传输过程中可能丢失。因此需要<strong>发布确认机制</strong>。也就是当消息真正的持久化到磁盘中时，消息队列会主动向生产者发送确认消息。<strong>因此总体上有三种机制保证队列和消息持久化：</strong></p>
<ol>
<li><p>设置要求队列必须持久化</p>
<p>声明队列时进行设置</p>
</li>
<li><p>设置要求队列中的消息必须持久化</p>
<p>发送消息时进行设置</p>
</li>
<li><p>发布确认</p>
<p>在获取信道后，可以开启发布确认：<code>channel.confirmSelect()</code>。</p>
</li>
</ol>
<p>那么究竟是发送一条就确认一条、还是发送若干条之后再统一确认呢？有单个、批量和异步三种。</p>
<h4 id="2-6-1-单个确认发布"><a href="#2-6-1-单个确认发布" class="headerlink" title="2.6.1 单个确认发布"></a>2.6.1 单个确认发布</h4><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitForConfirmOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定的时间范围内这个消息没有被确认，那么它将抛出异常。</p>
<p>这种确认方式有一个最大的缺点就是：发布速度特别慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说，这可能已经足够了。</p>
<p>1000条消息大概是658毫秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    String queueName = <span class="string">&quot;Single&quot;</span>;</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录时间开销</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量发送消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">// 单个消息马上进行发布确认</span></span><br><span class="line">        <span class="comment">// 该函数是只有收到确认后才会返回值，否则就等待。</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;单个确认总用时: &quot;</span> + (end - begin) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-批量确认发布"><a href="#2-6-2-批量确认发布" class="headerlink" title="2.6.2 批量确认发布"></a>2.6.2 批量确认发布</h4><p>通过实验发现，上面那种方式非常慢，与单个等待确认消息相比，先发送一批消息然后一起确认可以极大地提高吞吐量。这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出现了问题，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。<strong>这种方案仍然是同步的，也一样阻塞消息的发布</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    String queueName = <span class="string">&quot;Single&quot;</span>;</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录时间开销</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量发送消息</span></span><br><span class="line">    <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">// 批量确认</span></span><br><span class="line">        <span class="keyword">if</span>(i % batchSize == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;批量确认总用时: &quot;</span> + (end - begin) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量确认总用时约59毫秒。时间确实变短了，但是不是很安全。<strong>可以看出批量和单个的区别就是waitForConfirms方法的调用次数。</strong></p>
<h4 id="2-6-3-异步确认发布"><a href="#2-6-3-异步确认发布" class="headerlink" title="2.6.3 异步确认发布"></a>2.6.3 异步确认发布</h4><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没的说，它是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调保证是否投递成功。<strong>这里其实就是将确认控制权交给了消息队列，生产者无需等待消息队列发送确认后再次发送，而是一直发送。即下一次发送和上一次确认是异步的。</strong></p>
<p>而下面开启的监听器就是一个子线程，主线程就是不停地发送消息，子线程用于监听消息队列发送过来的消息，比如发送失败还是发送成功。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_015.png" alt="image-20221004143055542"></p>
<p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    String queueName = <span class="string">&quot;Single&quot;</span>;</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录时间开销</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备监听器，监听哪些消息成功了，哪些消息失败了。</span></span><br><span class="line">    <span class="comment">// 注意，一定是在发送消息前面</span></span><br><span class="line">    <span class="comment">// 消息确认成功的回调函数</span></span><br><span class="line">    ConfirmCallback ackCallback = (deliverTag, multiple) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;确认的消息：&quot;</span> + deliverTag);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息确认失败的回调函数</span></span><br><span class="line">    <span class="comment">// 第一个参数是 消息的标记</span></span><br><span class="line">    <span class="comment">// 第二个参数是 是否批量确认</span></span><br><span class="line">    ConfirmCallback nackCallback = (deliverTag, multiple) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;未确认的消息：&quot;</span> + deliverTag);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听器，第一个参数是监听成功，第二个参数是监听失败的。</span></span><br><span class="line">    channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量发送消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步确认，采用添加的监听器即可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;批量确认总用时: &quot;</span> + (end - begin) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有一个问题就是发送失败的消息没有存储，后续不能重新发送。<strong>但是这是两个线程，换句话说，即使监听器存储了消息，主线程还是无法获取到监听器存储的数据的，最好的解决办法就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如ConcurrentSkipListMap。</strong></p>
<ol>
<li>首先在发送的时候，记录已经发送的消息</li>
<li>监听器的确认回调函数中，删除确认成功的消息【因为一定是先发送再确认的，所以必定确认的是已经存在的】</li>
<li>最后剩余的就是没有发送成功的。</li>
</ol>
<p>性能最好，在出现错误的情况下可以很好地控制。</p>
<h3 id="2-7-交换机"><a href="#2-7-交换机" class="headerlink" title="2.7 交换机"></a>2.7 交换机</h3><p>上面的例子中，都没有使用交换机（采用默认交换机），交换机就是将消息路由到指定的队列中。</p>
<h4 id="2-7-1-概述"><a href="#2-7-1-概述" class="headerlink" title="2.7.1 概述"></a>2.7.1 概述</h4><p>RabbitMQ消息传递模型的核心思想是：生产者生产的消息不会直接发送到队列中。实际上，通常生产者甚至都不知道这些消息传递到了哪些队列中。</p>
<p>生产者只能将消息发送到交换机（Exchange），交换机工作的内容非常简单，一方面他接收来自生产者的消息，另一方面将他们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列呢？还是说放到许多队列？又或者是直接丢失呢？这就由交换机的类型来决定。<strong>交换机有如下几种类型（分别是）</strong>：</p>
<ol>
<li><strong>直连（direct）</strong>，<strong>路由</strong>，对应2.4模式</li>
<li><strong>主题（topic）</strong>，<strong>主题</strong>，对应2.5模式</li>
<li>标题（headers），使用较少</li>
<li><strong>扇出（fanout）</strong>，也就是<strong>发布订阅</strong>，对应2.3模式</li>
<li>无名，就是2.1、2.2中的，使用空串表示。本质上交换机是通过routingkey(bindingkey)来绑定队列的，即basicPublish()方法的第二个参数，如果交换机名称是空串，那么routingkey默认就是队列名称。</li>
</ol>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_018.png" alt="image-20221004163501250"></p>
<h4 id="2-7-2-临时队列"><a href="#2-7-2-临时队列" class="headerlink" title="2.7.2 临时队列"></a>2.7.2 临时队列</h4><p>没有被持久化的队列称为临时队列。</p>
<h4 id="2-7-3-绑定"><a href="#2-7-3-绑定" class="headerlink" title="2.7.3 绑定"></a>2.7.3 绑定</h4><p>绑定指的是交换机和队列之间的捆绑关系。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_017.png" alt="image-20221004163032595"></p>
<h2 id="3-高级部分"><a href="#3-高级部分" class="headerlink" title="3. 高级部分"></a>3. 高级部分</h2><h3 id="3-1-死信队列"><a href="#3-1-死信队列" class="headerlink" title="3.1 死信队列"></a>3.1 死信队列</h3><h4 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h4><p>死信，顾名思义就是无法被消费的消息。一般来说，生产者将消息投递到Broker后，消费者从队列中取出消息进行消费。但某些时候由于特定的原因导致队列中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，进而形成了死信队列。</p>
<p>注意，死信其实不能被丢失，而是被传送到死信交换机（dead_exchange）上，并进入死信队列（dead_queue）保存。</p>
<h4 id="3-1-2-应用场景"><a href="#3-1-2-应用场景" class="headerlink" title="3.1.2 应用场景"></a>3.1.2 应用场景</h4><p>应用场景：为了保定订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入到死信队列中。还有比如说：用户在商城下单成功后并点击去支付后在指定时间未支付时自动失效。</p>
<h4 id="3-1-3-死信的来源"><a href="#3-1-3-死信的来源" class="headerlink" title="3.1.3 死信的来源"></a>3.1.3 死信的来源</h4><p>死信有如下三个来源可造成：</p>
<ol>
<li>消息TTL过期</li>
<li>队列达到最大长度（队列满了，无法再添加数据到mq中），超出的消息成为死信。</li>
<li>消息被拒绝（basic.reject或basic.nack）并且requeue=false;</li>
</ol>
<h4 id="3-1-4-死信案例"><a href="#3-1-4-死信案例" class="headerlink" title="3.1.4 死信案例"></a>3.1.4 死信案例</h4><p>流程如下所示：</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_020.png" alt="image-20221004194304682"></p>
<ol>
<li><strong>声明普通交换机，声明普通队列，二者进行绑定</strong>，C1从该队列中获取消息</li>
<li><strong>声明死信交换机，声明死信队列，二者进行绑定</strong>，C2从该队列中获取消息</li>
<li><strong>死信交换机和普通队列具有一定的绑定关系，即当普通队列的消息称为死信时，需要将其转发到死信交换机</strong>。【可在普通队列声明时，通过最后一个参数进行设置转发到死信交换机】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明普通交换机、普通队列，并进行绑定，并与该</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个参数 就是设置消息称为死信后，将该信息转发到死信队列。</span></span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 正常队列设置死信交换机</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line"><span class="comment">// 设置死信routingkey</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.queueDeclare(NORMAL_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">channel.queueBind(NORMAL_QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明死信交换机、死信队列，并进行绑定</span></span><br><span class="line">channel.exchangeDeclare(DEAD_EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">channel.queueDeclare(DEAD_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(DEAD_QUEUE_NAME, DEAD_EXCHANGE_NAME, <span class="string">&quot;lisi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在生产者代码中设置消息的过期时间，第三个参数设置过期时间即可。当消息在TTL内没有被消费的话，自动转为死信，之后根据上面绑定的关系，会转发到死信交换机，并传输到死信队列中，最终有C2消费者获取到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置过期时间，超过时间后消息成为死信</span></span><br><span class="line">        <span class="comment">// 单位是毫秒，10秒后过期</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            String message = <span class="string">&quot;info&quot;</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意，第三个参数设置过期时间</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么该怎么测试呢？<strong>可先开启消费者1，创建死信队列、死信交换机、普通队列、普通交换机等信息。</strong>然后关闭该消费者1，开启消费者2，并开启生产者发送消息，这样，生产者产生的消息肯定不会被普通消费者C1消费，等待TTL后，会成为死信，被消费者2消费。</p>
<p>下面是没开启消费者2的时候的情况转变，开启生产者后，普通队列中的10条数据在10秒后均成为死信，放在了死信队列中。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_021.png" alt="image-20221004203328898"></p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_022.png" alt="image-20221004203412672"></p>
<p>消费者2其实就是普通消费者，只不过消费的是死信队列，这里代码不再赘述。</p>
<p>上面是超时称为死信，下面测试一下队列满了之后多余的信息成为死信，即超过队列长度之后，设置队列长度和设置死信队列类似，也是在第三个参数设置。【注意，此时在生产者发送消息时，无需设置TTL了】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置队列长度，超过之后，消息称为死信。</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>同样先打开消费者C1，创建队列和交换机，然后关闭该消费者，打开生产者，生产10个消息。打开后台可以发现，多余的4条信息在死信队列中。【<strong>经过测试，发现先产生的消息成为了死信，而不是后产生的消息</strong>】</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_023.png" alt="image-20221004204642117"></p>
<p>第三种情况是消息被拒绝，此时如果要模拟这种情况，在消费者处必须是手动应答，不能是自动应答。那么手动应答和手动拒绝，就是在回调函数中，判断是否拒绝，并给出拒绝和应答。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE_NAME = <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE_NAME = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE_NAME = <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明普通交换机、普通队列，并进行绑定，并与该</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一个参数 就是设置消息称为死信后，将该信息转发到死信队列。</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line">        <span class="comment">// 设置死信routingkey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置队列长度，超过之后，消息称为死信。</span></span><br><span class="line"><span class="comment">//        arguments.put(&quot;x-max-length&quot;, 6);</span></span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">        channel.queueBind(NORMAL_QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明死信交换机、死信队列，并进行绑定</span></span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(DEAD_QUEUE_NAME, DEAD_EXCHANGE_NAME, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息时的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在这里拒绝消息，即不处理。比如拒绝消息是info5的消息，那么死信队列就是</span></span><br><span class="line">            <span class="keyword">if</span>(message.getBody().equals(<span class="string">&quot;info5&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;本消息是拒绝的：&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">                <span class="comment">// 被拒绝，不再放回普通队列，</span></span><br><span class="line">                channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 得到消息体</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">                <span class="comment">// 正常应答，不批量应答</span></span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消消息时的回调</span></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="comment">// 注意，第二个参数，是开启手动应答，否则不会出现拒绝，</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，死信队列中只有info5。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_024.png" alt="image-20221004210835184"></p>
<h3 id="3-2-延迟队列"><a href="#3-2-延迟队列" class="headerlink" title="3.2 延迟队列"></a>3.2 延迟队列</h3><h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><p>延迟队列其实就是死信队列三种中的一种，即TTL造成的死信。此时死信队列消费者消费到消息，与生产者生产消息后就会产生一定的延迟。</p>
<p>延迟队列，队列内部是有序的，最重要的特定就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理。简单来说，延迟队列就是用来存放需要在指定时间被处理的元素的队列。</p>
<h4 id="3-2-2-应用场景"><a href="#3-2-2-应用场景" class="headerlink" title="3.2.2 应用场景"></a>3.2.2 应用场景</h4><ol>
<li>订单在十分中之内未支付则自动取消</li>
<li>新创建的店铺，如果在十天之内都没有上传过商品，则自动发送消息提醒。</li>
<li>用户注册成功后，如果三天内没有登录则进行短信提醒。</li>
<li>用户发起退款后，如果三天内没有得到处理则通知相关运营人员。</li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。</li>
</ol>
<blockquote>
<p>初步看这些应用场景，其实都有一个特点，就是需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；这看起来似乎使用定时任务，一直轮询数据，每秒查询一次，取出需要被处理的数据，然后处理不就完了吗？</p>
<p>如果数据量比较少，确实可以这样做，比如对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的订单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如“订单十分钟内未支付则关闭”，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显示是不可取的，很可在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>
</blockquote>
<p>一个买火车票的流程</p>
<blockquote>
<ol>
<li>用户抢购车票并前往付款界面，生成订单，付款状态为：未支付</li>
<li>根据订单id等信息生成消息到RabbitMQ队列（设置延迟TTL时间为30分钟）</li>
<li>当到达30分钟后，会进入到延迟队列，延迟队列消费者会获取到消息，根据消息去订单数据库查询对应的订单，判断是否付款，如果未付款，那么更新订单为失效状态【即到期自动取消】，并车票数量加1。如果已付款，那么则无需操作。</li>
<li>如果用户在30分钟之内已付款，那么就根据付款操作修改数据库订单状态即可，【方便第3步匹配】</li>
</ol>
</blockquote>
<h4 id="3-3-3-案例"><a href="#3-3-3-案例" class="headerlink" title="3.3.3 案例"></a>3.3.3 案例</h4><p>为了演示延迟队列案例，需要先见第5节，基于SpringBoot整合RabbitMQ。案例结构如下所示：</p>
<p>一个生产者，一个普通交换机，两个普通队列，一个延迟10秒，一个延迟40秒。一个延迟交换机，一个延迟队列。一个消费者。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_025.png" alt="image-20221004222711106"></p>
<h3 id="3-3-发布确认高级"><a href="#3-3-发布确认高级" class="headerlink" title="3.3 发布确认高级"></a>3.3 发布确认高级</h3><h3 id="3-4-幂等性"><a href="#3-4-幂等性" class="headerlink" title="3.4 幂等性"></a>3.4 幂等性</h3><h3 id="3-5-优先级队列"><a href="#3-5-优先级队列" class="headerlink" title="3.5 优先级队列"></a>3.5 优先级队列</h3><h3 id="3-6-惰性队列"><a href="#3-6-惰性队列" class="headerlink" title="3.6 惰性队列"></a>3.6 惰性队列</h3><h2 id="4-集群部分"><a href="#4-集群部分" class="headerlink" title="4. 集群部分"></a>4. 集群部分</h2><h2 id="5-SpringBoot整合RabbitMQ"><a href="#5-SpringBoot整合RabbitMQ" class="headerlink" title="5. SpringBoot整合RabbitMQ"></a>5. SpringBoot整合RabbitMQ</h2><p>创建普通SpringBoot项目即可，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- swagger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- RabbitMQ测试依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置配置文件application.properties，设置连接RabbitMQ的参数。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">admin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 这是为了 防止出现这个错误 java.lang.NullPointerException:</span></span><br><span class="line"><span class="comment"># Cannot invoke &quot;org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.toString()&quot;</span></span><br><span class="line"><span class="comment"># because the return value of &quot;springfox.documentation.spi.service.contexts.Orderings.patternsCondition(springfox.documentation.RequestHandler)&quot; is null</span></span><br><span class="line"><span class="comment"># https://www.cnblogs.com/huyueping/p/15607970.html</span></span><br><span class="line"><span class="comment"># 因为springboot2.6以及以上，会与springfox出现问题</span></span><br><span class="line"><span class="meta">Spring.mvc.pathmatch.matching-strategy</span>=<span class="string">ant_path_matcher</span></span><br></pre></td></tr></table></figure>

<p>创建config文件，用于swagger页面显示API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;rabbitmq接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了rabbitmq微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;hianian&quot;</span>, <span class="string">&quot;http://www.hianian.xyz&quot;</span>, <span class="string">&quot;hianian@gmail.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用SpringBoot，可直接用配置文件将交换机和队列声明出来，这样无需在消费者代码中再声明了，逻辑更加清晰。</p>
<h3 id="5-1-配置文件声明交换机队列"><a href="#5-1-配置文件声明交换机队列" class="headerlink" title="5.1 配置文件声明交换机队列"></a>5.1 配置文件声明交换机队列</h3><p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTLQueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE_D = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(NORMAL_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通队列A</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 设置死信交换机等参数</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(NORMAL_QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通队列B</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 设置死信交换机等参数</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(NORMAL_QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DEAD_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_QUEUE_D).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定队列和交换机，这里仍然是创建对象，只不过这个对象不会被使用，但是里面的代码是需要执行的，即绑定过程</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueDBindingY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-生产者"><a href="#5-2-生产者" class="headerlink" title="5.2 生产者"></a>5.2 生产者</h3><p>在Controller中写生产者，生产者可以发往10秒的延迟队列中，也可发往40秒的延迟队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始发送消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;, 发送一条消息给两个TTL队列：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), message);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自ttl为10s的队列：&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自ttl为40s的队列：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-消费者"><a href="#5-3-消费者" class="headerlink" title="5.3 消费者"></a>5.3 消费者</h3><p>消费者是监听器的形式出现的。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，收到私信队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-结果验证"><a href="#5-4-结果验证" class="headerlink" title="5.4 结果验证"></a>5.4 结果验证</h3><p>启动项目，在浏览器输入<code>http://localhost:8080/ttl/sendMsg/嘻嘻嘻</code>，可以看到，控制台在一定的时间间隔内输出了内容，即消费者在指定的时间内确实获取到了私信队列的消息。</p>
<p><img src="D:%5Cothers%5Cstudy_source%5CGithubBlog%5CBlogImageBed%5Cblog-image-bed%5CJavaWeb%5Crabbitmq%5Crabbitmq_026.png" alt="image-20221004233129631"></p>
<p>也就是说，消费者（监听器）已监听到死信队列QD中有消息了，就立马获取消息。而死信队列是由于普通队列中的消息TTL到期了，自动转为死信。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>总体来看，我有以下理解：</p>
<ol>
<li>消费者要想获取消息，必须获取连接，获取信道。必须声明要获取的交换机（如果该交换机已经存在可以不声明），以及队列，将二者进行绑定。这样，交换机在收到消息后，才能将消息按照一定的模式规则将消息发送到该队列中，从而消费者获取到消息。</li>
<li>生产者要想发送消息，必须获取连接，获取信道。必须声明交换机（如果该交换机已经存在可以不声明），将消息发送到指定的交换机。</li>
<li>由于生产者只是在将消息发送到交换机，所以可以无需声明队列。而消费者需要从队列中获取消息，所以最好在消费者处声明队列（如果没有）。至于交换机，在消费者/生产者处都可声明。</li>
</ol>
<p>另外，队列和交换机绑定是有一定规则的。比如路由、发布订阅等。<strong>队列和交换机绑定，可以绑定多次规则</strong>。</p>
<h2 id="7-备注"><a href="#7-备注" class="headerlink" title="7. 备注"></a>7. 备注</h2><p><em>参考B栈《尚硅谷》。</em></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">浮云</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://ihianian.github.io/2022/10/02/JavaWeb-18-RabbitMQ/">https://ihianian.github.io/2022/10/02/JavaWeb-18-RabbitMQ/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">浮云</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JavaWeb/">
                                    <span class="chip bg-color">JavaWeb</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/null" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/null" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/10/02/JavaWeb-19-Nginx/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="JavaWeb_19_Nginx">
                        
                        <span class="card-title">JavaWeb_19_Nginx</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-10-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            浮云
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaWeb/">
                        <span class="chip bg-color">JavaWeb</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/08/22/%E7%A7%8B%E6%8B%9B-%E9%A1%B9%E7%9B%AE%E5%A4%8D%E4%B9%A0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="秋招_项目复习">
                        
                        <span class="card-title">秋招_项目复习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-08-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            浮云
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%A7%8B%E6%8B%9B/">
                        <span class="chip bg-color">秋招</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2023</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">hianian</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">600.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">














    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
